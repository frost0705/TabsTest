      Целые числа с неограниченной разрядной сеткой

             (класс cBigNumber, версия 2.0)

                Руководство программиста

                                    Посвящается маме.

Содержание
==========

1. Введение

1.1. Совместимость
1.2. Технические параметры
1.3. Лицензионное соглашение
1.4. Обязательства автора
1.5. Компоненты, разработанные третьими сторонами
1.6. Техническая поддержка
1.7. Контактная информация
1.8. Благодарности

2. Состав дистрибутива

2.1. Тестовые программы

3. Правила применения

3.1. Объявление неограниченных чисел и штатные операции C++
3.2. Дополнительные операции, функции и методы
3.3. Функции и методы для ручной оптимизации программ
3.4. Определение простых чисел и факторизация

4. Рекомендации по применению

4.1. Возможные области применения
4.2. Производительность
4.3. Расход памяти
4.4. Взаимодействие с операционной системой
4.5. Предупреждение ошибок
4.6. Встроенные средства предупреждения ошибок

5. Технические сведения

5.1. Сведения о реализации
5.2. Особенности реализации штатных операций

Приложение 1: Пояснительная записка к работе на конкурс SofTool'99

Приложение 2: Известные ошибки

Приложение 3: Что нового


1. Введение
===========

Класс cBigNumber вводит целые числа неограниченной разрядности,
над которыми могут выполняться все штатные операции языка C++:
арифметические, логические, побитовые, сравнение, сдвиги, а также
потоковый ввод-вывод со всеми целочисленными модификаторами.
Дополнительные функции - возведение в степень, возведение в
степень по модулю и проверка на простоту по методу Миллера.

Класс оптимизирован для работы с числами размером до 100,000
двоичных разрядов. Испытания проводились для чисел, содержащих
до 12,000,000 двоичных разрядов.


1.1. Совместимость
------------------

Класс создается в соответствии со стандартом C++
ISO/IEC 14882:1998(E).

Реализация класса не зависит от разрядности конкретного
вычислительного устройства, но предполагается, что числа
представляются в дополнительном двоичном коде.

Тестирование класса проводится в следующих трансляторах:
- Microsoft Visual C++ 6.0, 7.0, SDK 2003 R2, 2005, 2008, 2010.
- Borland C++ 3.1 (16-разрядный режим).
- Borland C++ 4.5 (32-разрядный режим).
- Borland C++ Builder 1.0.
- GNU g++ 2.9.6 (32-разрядный режим, Red Hat Linux 7.1).
- GNU g++ 3.3.3 (ARM, Pocket GCC, Windows Mobile 5, 6.1).
- GNU g++ 4.1.2 (64-разрядный режим, SuSE Linux 10).
- GNU g++ 4.2.3 (32-разрядный режим, Workbench).

Код с 32-разрядной ассемблерной оптимизаций доступен как
дополнительный пакет для следующих трансляторов:
- Microsoft Visual C++ 6.0, 7.0, 2003-2010.
- Borland C++ Builder 1.0 и выше.
- Borland C++ 4.5 (32-разрядный режим, более медленное умножение).

Код с 64-разрядной ассемблерной оптимизаций доступен как
дополнительный пакет для Microsoft Visual C++ 2008-2010,
протестирован под:
- Microsoft Visual C++ 2010, SDK 7.1 x64

Код с 32/64-разрядным ассемблерным умножением доступен как
дополнительный пакет для GNU g++, протестирован под:
- GNU g++ 2.9.6 (32-разрядный режим, Red Hat Linux 7.1).
- GNU g++ 4.1.2 (64-разрядный режим, SuSE Linux 10).

Класс поддерживает многопоточность, подробная информация
приведена в разделах 3 и 4.2.4.


1.2. Технические параметры
--------------------------

Технические параметры рассчитаны в предположении, что байт
содержит 8 бит, машинное слово содержит 16, 32 или 64 бита
типа size_t. Некоторые параметры зависят от размера CBNL
слова языка С, которое содержит 32 или 64 разрядное целое
стандартного типа long или зависимого от компилятора типа,
определенного в файле Cbnl.h.

- Размер дескриптора числа в машинных словах:            2

- Представление числа:  нормализованный дополнительный двоичный
                        код с переменным числом CBNL слов С
                        в порядке от младших слов к старшим

- Начальное значение числа по умолчанию:                 0

- Начальный размер динамической памяти, выделяемой
  для числа 0, в байтах:                                 0

- Размер служебной информации для представления
  числа, в CBNL словах:         число 0:           0 или 2
                                число не 0:              2

- Минимальный размер памяти, выделяемой для
  для не-0 числа, в CBNL словах (*):                     3

- Начальный размер динамической памяти, выделяемой
  для не-0 числа, в байтах (*): 16 разр.:               44
                                32 разр.:              104
                                64 разр.:              224

- Максимальный размер памяти, выделяемой
  для числа, в байтах (*):      16 разр.:           34,988
                                32 разр.:    1,607,077,576
                                64 разр.:        системный

- Максимальное число операций распределения
  памяти для числа в зависимости от размера
  кода числа n, в байтах (*):   16 разр.:2*log3 ((n+4)/ 96)
                                32 разр.:2*log3 ((n+8)/224)
                                64 разр.:2*log3((n+16)/480)

- Размер автоматически резервируемой памяти
  по отношению к фактическом размеру двоичного
  кода числа (**)                         в среднем: 37.5%
                                          максимум:   100%

- Максимальный расход памяти на оптимизацию
  операции умножения,           16 разр.:               3K
  в байтах (***,****)           32 разр. и более:      90K

- Расход памяти на оптимизацию операции
  деления по отношению к размеру
  делителя (***,*****):         32 разр. CBNL:       3200%
                                64 разр. CBNL:       6400%

- Максимальный расход памяти на оптимизацию
  операции деления,             16 разр.:               2K
  в байтах (***,*****):         32 разр. и более:      64M

(*)     Включает в себя служебную информацию.

(**)    Предполагается, что размер числа больше минимального.

(***)   Кроме операций c таблицей сдвигов.

(****)  Не включает в себя затраты на промежуточное копирование,
        равные размеру операндов.

(*****) Оптимизация проводится для делителей размером до 60 байт
        в 16-разрядном режиме, до 2M байт в 32-разрядном режиме
        и до 1M байт в 64-разрядном режиме.


1.3. Лицензионное соглашение
----------------------------

Все авторские права на данный программный код исчерпывающе
описываются нижеследующим копирайтом:

Copyright 1999-2011, Р.Н.Шакиров, ИМаш УрО PAH.

Функционально полная версия исходного кода, написанная
на стандартном С+ без использования машинных команд,
предоставляется на условиях лицензии "public domain",
т.е. допускается свободное применение, модификация и
распространение кода при при условии размещения данного
копирайта в доступной для конечного пользователя
документации, а также добавления исчерпывающих сведений
о всех внесенных в данный код изменениях.

Данное соглашение не ограничивает Ваши исключительные права
на разработки, выполненные с применением данного кода и
накладывает на Вас какие-либо иные обязательства, кроме
упоминания об авторстве данного кода.


1.4. Обязательства автора
-------------------------

Автор подтверждает, что он урегулировал все юридические вопросы,
связанные с использованием в разработанном им программном коде
интеллектуальной собственности третьих сторон.

Автор гарантирует, что разработанный им программный код не
содержит компоненты, назначение которых отлично от основной
цели, декларированной в данной документации.

ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПО ПРИНЦИПУ
"КАК ЕСТЬ" ("AS IS") БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ
ПОДРАЗУМЕВАЕМЫХ. ВЫ ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ
И РИСК. АВТОР НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ,
УЩЕРБ, УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.


1.5. Компоненты, разработанные третьими сторонами
-------------------------------------------------

1. Strong Probable Primarily test for base b
   by Olivier Langlois <olanglois@sympatico.ca>
   Общедоступный код.

2. Tausworth based random number generator.
   Ref. Glenn Rhoads' home page at
   http://remus.rutgers.edu/~rhoads/Code/code.html
   Общедоступный код.

3. Microsoft(R) Visual C++ 6.0 Compiler (Enterprise Edition).
   Лицензирован для Института машиноведения УрО РАН.

4. MSDN Subscriptions library, April 2001
   Лицензирована для Института машиноведения УрО РАН.

5. Microsoft(R) Visual C++ 2010 Express Compiler.
   Общедоступное программное обеспечение.

6. Microsoft(R) Windows SDK v7.1 x64.
   Общедоступное программное обеспечение.

7. GNU C++ compiler g++ 2.9.6
   Общедоступное программное обеспечение.

8. GNU C++ compiler g++ 4.1.2
   Общедоступное программное обеспечение.


1.6. Техническая поддержка
--------------------------

Обеспечивается на сайте http://www.imach.uran.ru/cbignum

Просьба отсылать автору свoи конструктивные предложения,
а также сообщения об ошибках и проблемах совместимости.


1.7. Контактная информация
--------------------------

Автор:  к.т.н. Рауль Нурович Шакиров
620219, Россия. г.Екатеринбург, ул.Комсомольская, 34,
Институт Машиноведения УрО РАН.

Тел.:   +7 (343) 375-35-80
Почта:  raul@imach.uran.ru


1.8. Благодарности
------------------

Автор выражает благодарность к.ф-м.н. Н.В.Невесенко за обсуждение
идей в области алгоритмов целочисленных вычислений.


2. Состав дистрибутива
======================

Класс cBigNumber реализован в виде следующих файлов:

   Cbignum.cpp  - реализация методов класса cBigNumber
   Cbignum.h    - декларации и inline - функции класса cBigNumber
   Cbignum.txt  - руководство по применению класса (англ.)
   Cbignumr.txt - руководство по применению класса (рус.)
   Cbignumf.cpp - реализация базовых арифметических функций над
                  неограниченными числами с применением машинных
                  команд (в дополнительном пакете)
   Cbignumf.inl - реализация базовых арифметических функций
                  над неограниченными числами на стандартном C++
   Cbignumf.h   - макропараметры для базовых арифметических функций
   Cbignums.cpp - реализация операторов потокового ввода-вывода
   Cbignums.h   - декларации операторов потокового ввода-вывода
   Cbnl.h       - декларации для определения компилятора
   Cbnl.inl     - декларации для определения компилятора
   Cbnl64.inl     (в дополнительном пакете)
   Cios.h       - декларации стандартного потокового ввода-вывода
   Cthr.h       - декларации для поддержки многопоточности
   Ctty.cpp     - обработчики независимого потокового вывода
   Ctty.h       - класс для независимого потокового вывода
   Ctty.txt     - руководство по применению класса (рус.)
   Cttyr.txt    - руководство по применению класса (англ.)
   Exarray.cpp  - функции распределения памяти
   Exarray.h    - шаблон динамических массивов
   Exarray.txt  - руководство по применению шаблона (англ.)
   Exarrayr.txt - руководство по применению шаблона (рус.)
   Exdebug.h    - отладочные макросы шаблона
   Exstring.h   - переопределения функций string.h
   Exthread.h   - макро локальной памяти потока
   Prime.cpp    - тестовые функции для определения простых чисел
   ENG\         - исходные коды с комментариями (англ.)
   RUS\         - исходные коды с комментариями (рус.)

Дополнительный пакет также содержит:
   Cbnl32.obj   - 32-разрядный объектный файл
   Cbnl64.obj   - 64-разрядный объектный файл

Файл Cbignumr.txt описывает документированные функции класса,
которые будут сохранены в последующих версиях класса, если
только в соответствующем разделе не оговорено противное.

Для удобства изучения в файлы *.cpp и *.h встроены
комментарии, которые могут рассматриваться, как
дополнительная документация. Если программисты будут
испытывать затруднения при ознакомлении с текстами,
то автор всегда будет рад им помочь.

ПРЕДУПРЕЖДЕНИЕ:
Все определения файлов *.cpp и *.h, не обеспечивающие
штатные операции языка C++ и не перечисленные в
файле Cbignumr.txt, считаются недокументированными.
Они могут быть исключены или модифицированы в
последующих реализациях без каких-либо уведомлений.


2.1. Тестовые программы
-----------------------

Тестовые программы откомпилированы в 32-разрядном режиме
для операционных систем Windows и Linux и в 64-разрядном
режиме для Linux.

На больших числах программы для Windows работают в несколько
раза быстрее, чем соответствующие программы для Linux,
т.к. компиляция для Windows проводилась с использованием
встроенного ассемблера x386.

При обработке больших чисел примерный размер требуемой
памяти равен удвоенному суммарному размеру исходных
данных и результата. Максимальный объем адресуемой
виртуальной памяти в 32-разрядном режиме равен 2G.

Программы работают с числами вo внешнем десятичном
представлении.

Для сборки всех программ можно использовать следующие файлы:

   Cbignum      - команды для GNU g++
   Cbignum.dsw  - рабочая область Microsoft Visual C++ 6.0
   Cbignumd     - команды для GNU g++ (отладочный режим)

Тестовые программы и инструкции сборки для PocketPC включены
в дополнительный пакет.


2.1.1. Целочисленный калькулятор Arifexp
----------------------------------------

Программа Arifexp выполняет арифметические вычисления, которые
задаются в виде следующих выражений:
a=      (вывести число)
a+b=    (сложение)
a-b=    (вычитание)
a*b=    (умножение)
a/b=    (деление с остатком)
a%b=    (остаток)
a\b=    (степень)
a<<b=   (сдвиг влево)
a>>b=   (сдвиг вправо)
a|b=    (дизъюнкция)
a&b=    (конъюнкция)
a^b=    (исключающее или)
a?b=    (сравнение, выдает -1,0,1)
a+b*c=  (умножение со сложением)
a-b*c=  (умножение с вычитанием)
a\b%c=  (степень по модулю)
2Vb=    (квадратный корень с остатком)
После каждого числа может стоять суффикс R, который заказывает
генерацию случайного числа с заданным знаком и числом значащих
бит, не большим CBNL_MIN.

Между операндами и знаками операций разрешается добавлять пробелы,
табуляции и переводы строк. За раз можно задать несколько выражений,
которые вычисляются независимо друг от друга.

При запуске программы можно указать следующие опции:
-idle   низкий приоритет
-high   высокий приоритет
-par n  выполнять до n параллельных потоков (сейчас 1 или 2)
-hex    шестнадцатеричный ввод/вывод
-hexi   шестнадцатеричный ввод
-hexo   шестнадцатеричный вывод
-div0   разрешить деление на 0
-size   показывать старшее слово и размер чисел
-time   показывать оценку времени операции в машинных циклах Athlon
-v      выводить выражение перед результатом
-rep n  повторять операцию n раз
-check  проверять результат операций, если это возможно
-rand   подставить в выражение случайные числа вместо вычисления:
        положительное число длины n вместо n
        отрицательное число длины n вместо -n
        число -8,-4,-2,-1,0,1,2,4,8 вместо 0, если указано -rand 0
        включая показатели степени и сдвига, если указано -rand all
-exp n  добавить до n нулей к случайным числам
-help   справка о программе

Опции приоритета и параллельности поддерживаются только под Windows
в зависимости от компилятора. Если они активированы, то программа
сообщает "Idle priority", "High priority" или "Run concurrent thread
for output".

После опций можно указать имя файла с выражениями.

   ПРИМЕЧАНИЕ: Для формирования и запуска теста можно воспользоваться
               следующими командами:
   Arifexp -rand >input
   Arifexp input >output

Программа выдает код возврата:
    0 - нормальное завершение
    1 - обнаружена ошибка в результате операции (опция -check)
  255 - обнаружена ошибка в опциях или исходных данных

Состав программы:

   Arif         - тест
   Arif.bat     - запуск теста
   Arif.res     - эталон для сравнения с результатом
   Arif.sh      - запуск теста под Linux
   Arif.wrk     - результат

   Arif1        - тест умножения с накоплением
   Arif1.bat    - запуск теста
   Arif1.res    - эталон для сравнения с результатом
   Arif1.sh     - запуск теста под Linux
   Arif1.wrk    - результат

   Arif2        - тест возведения в степень по модулю
   Arif2.bat    - запуск теста
   Arif2.res    - эталон для сравнения с результатом
   Arif2.sh     - запуск теста под Linux
   Arif2.wrk    - результат

   Arif3        - тест умножения
   Arif3.bat    - запуск теста
   Arif3.res    - эталон для сравнения с результатом
   Arif3.sh     - запуск теста под Linux
   Arif3.wrk    - результат

   Arif4        - тест деления с остатком
   Arif4.bat    - запуск теста
   Arif4.res    - эталон для сравнения с результатом
   Arif4.sh     - запуск теста под Linux
   Arif4.wrk    - результат

   Arif5        - тест квадратного корня с остатком
   Arif5.bat    - запуск теста
   Arif5.res    - эталон для сравнения с результатом
   Arif5.sh     - запуск теста под Linux
   Arif5.wrk    - результат

   Arifr        - шаблон теста
   Arifr.bat    - запуск теста генератора случайных чисел
   Arifr.sh     - запуск теста генератора случайных чисел под Linux
   Arifr.wrk    - последний полученный результат

   Arifrand     - шаблон теста
   Arifrand.1   - тест с короткими случайными числами
   Arifrand.2   - тест с длинными случайными числами
   Arifrand.b1  - Arifrand.1 для последнего некорректного результата
   Arifrand.b2  - Arifrand.2 для последнего некорректного результата
   Arifrand.bad - последний некорректный результат (см. NO MATCH)
   Arifrand.bat - запуск циклического теста под Windows
   Arifrand.res - накопитель кодов возврата для циклов теста
   Arifrand.sh  - запуск циклического теста под Linux
   Arifrand.wrk - последний полученный результат

   Arifexp      - исполняемый файл программы для Linux
   Arifexp.cpp  - текст программы
   Arifexp.dsp  - файл проекта для Microsoft Visual C++ 6.0
   Arifexp.exe  - исполняемый файл программы для Win32
   Arifexp.prj  - файл проекта для Borland C++ 3.1
   Arifexp64    - исполняемый файл программы для Linux x64
   Arifexp64.exe- исполняемый файл программы для Win64

   Gettimer.c   - функции для замера производительности
   Gettimer.h     и установки приоритета

   Random3.c    - генератор случайных чисел
   Random3.h
   Random3.txt  - документация (англ.)
   Random3r.txt - документация (рус.)


2.1.2. Программа перемножения квадратных матриц Matrix
------------------------------------------------------

Программа перемножения квадратных матриц реализована
с использованием чисел cBigNumber и шаблона динамических
массивов exarray, положенного в основу класса cBigNumber.

Программа демонстрирует современную технику программирования,
при которой отсутствует необходимость управления распределением
памяти со стороны программиста, т.к. динамические массивы
exarray имеют неограниченные размеры по всем измерениям.
На взгляд автора, идея неограниченного массива удачно дополняет
концепцию чисел без ограничения разрядности.

В тексте программы предусмотрены макроопределения, позволяющие
при компиляции отказаться от динамических массивов в пользу
обыкновенного статического распределения памяти, а также
поменять формат представления чисел.

Состав программы:

   10           - исходные данные для перемножения матриц 10*10
   10.bat       - тест перемножения матриц 10*10
   10.res       - эталон для сравнения с результатом перемножения
   10.sh        - тест перемножения матриц 10*10 под Linux
   10.wrk       - результат перемножения

   100          - исходные данные для перемножения матриц 100*100
   100.bat      - тест перемножения матриц 100*100
   100.res      - эталон для сравнения с результатом перемножения
   100.sh       - тест перемножения матриц 100*100 под Linux
   100.wrk      - результат перемножения

   Gettimer.c   - функции для замера производительности
   Gettimer.h     и установки приоритета.

   Matrix       - исполняемый файл программы для Linux
   Matrix.cpp   - текст программы
   Matrix.dsp   - файл проекта для Microsoft Visual C++ 6.0
   Matrix.exe   - исполняемый файл программы для Win32
   Matrix.prj   - файл проекта для Borland C++ 3.1
   Matrix.txt   - инструкция по подготовке исходных данных (ангп.)
   Matrix64     - исполняемый файл программы для Linux x64
   Matrix64.exe - исполняемый файл программы для Win64
   Matrixr.txt  - инструкция по подготовке исходных данных (рус.)


2.1.3. Программа определения простых чисел Miller
-------------------------------------------------

Программа Miller запрашивает число и определяет его простоту
по методике, изложенной на странице
   http://www.utm.edu/research/primes/prove/prove3.html
Диалог ведется на английском языке.

При запуске программы можно указать следующие опции:
-idle   низкий приоритет
-high   высокий приоритет
-hex    шестнадцатеричный ввод/вывод
-hexi   шестнадцатеричный ввод
-hexo   шестнадцатеричный вывод
-factor факторизация по методу "грубой силы" (самый медленный тест)
-proved быстрый тест SPRP 2..17 и факторизация  (быстрее и не хуже)
-miller факторизация по 2..7919 и полный тест Миллера (еще быстрее)
-strong факторизация по 2..7919 и SPRP 2..17 (очень быстрый, вероятностный)
-scan n проверить указанное число значений с шагом 2
-help   справка о программе
После опций можно указать имя файла с проверяемым числом.

Если способ проверки не выбран, то проводится два независимых теста:
вероятностный по Миллеру и факторизация. При корректной работе программы
результаты этих двух тестов не должны противоречить друг другу.

Программа выдает код возврата:
    0 - составное
    1 - простое по поиску делителей
    2 - простое по малым SPRP
    3 - возможно простое по Миллеру
    7 - возможно простое по малым SPRP
   11 - простое по поиску делителей, но SPRP-составное (ошибка)
   12 - простое по малым SPRP, но есть делитель        (ошибка)
   13 - возможно простое по Миллеру, но есть делитель  (ошибка)
  255 - обнаружена ошибка в опциях или входных данных
Если с опцией scan проверено несколько чисел, то выдается
максимальный код.

Состав программы:

   Gettimer.c   - функции для замера производительности
   Gettimer.h     и установки приоритета.

   Mill.bat     - запуск тестов для чисел Miller.9 - Miller.1
   Mill.sh      - запуск тестов для чисел Miller под Linux
   Miller       - исполняемый файл программы для Linux
   Miller.1     - большое простое число:
                  тест не доходит до конца, но по нему можно
                  судить о степени вероятности...
   Miller.2-9   - числа поменьше и попроще.
   Miller.cpp   - текст программы
   Miller.dsp   - файл проекта для Microsoft Visual C++ 6.0
   Miller.exe   - исполняемый файл программы для Win32
   Miller.prj   - файл проекта для Borland C++ 3.1
   Miller64     - исполняемый файл программы для Linux x64
   Miller64.exe - исполняемый файл программы для Win64

   Millrand     - шаблон теста
   Millrand.1   - случайное число
   Millrand.2   - случайное нечетное число для теста
   Millrand.b1  - Millrand.1 для последнего некорректного результата
   Millrand.b2  - Millrand.2 для последнего некорректного результата
   Millrand.bad - последний некорректный результат (см. NO MATCH)
   Millrand.bat - запуск циклического теста под Windows
   Millrand.res - накопитель кодов возврата для циклов теста
   Millrand.sh  - запуск циклического теста под Linux
   Millrand.wrk - последний полученный результат


3. Правила применения
=====================

Для применения класса cBigNumber следует:

1.  Разместить в рабочем каталоге файлы:
        Cbignum.cpp
        Cbignum.h
        Cbignumf.cpp
        Cbignumf.h
        Cbignumf.inl
        Cbignums.cpp (опция для операций потокового ввода-вывода)
        Cbignums.h   (опция для операций потокового ввода-вывода)
        Cbnl.h
        Cbnl.inl
        Cbnl64.inl
        Cios.h       (опция для поддержка ввода-вывода)
        Ctty.cpp     (опция для операций вывода на консоль)
        Ctty.h
        Exarray.cpp
        Exarray.h
        Exdebug.h
        Exthread.h
        Prime.cpp    (опция для проверки чисел на простоту)
    Если используется дополнительный пакет, то в рабочий каталог
    добавить файл:
        Cbnl32.obj   (для 32-разрядного режима компиляции,
                      если в Cbnl.inl установлено макро _CBNL_ML)
        Cbnl64.obj   (для 64-разрядного режима компиляции,
                      если в Cbnl64.inl установлено макро _CBNL_ML)

2.  Включить в проект файлы:
        Cbignum.cpp
        Cbignumf.cpp
        Cbignums.cpp (опция для операций потокового ввода-вывода)
        Ctty.cpp     (опция для операций вывода на консоль)
        Exarray.cpp
        Prime.cpp    (опция для проверки чисел на простоту)
    Если используется дополнительный пакет, то добавить в проект файл:
        Cbnl32.obj   (для 32-разрядного режима компиляции,
                      если в Cbnl.inl установлено макро _CBNL_ML)
        Cbnl64.obj   (для 64-разрядного режима компиляции,
                      если в Cbnl64.inl установлено макро _CBNL_ML)

    ПРИМЕЧАНИЕ: Опциональные файлы потокового ввода-вывода и вывода
                на консоль используют библиотеку потокового ввода-вывода
                языка C++, которая существует в двух вариантах: старом
                (iostream.h) и стандартном (iostream). Старые компиляторы
                могут не иметь стандартную библиотеку, в то время как
                новые выдают для старой библиотеки предупреждения или
                вообще не включают ее начиная с Microsoft Visual C++ 2005.
                А если компилятор Microsoft допускает обе библиотеки, то
                во всем проекте может использоваться только одна из них
                т.к. их совместное использование не допускается.

                По умолчанию класс подключает старую библиотека, за
                исключением случаев применения компиляторов Microsoft
                Visual C++ NET, 2003-2010 и выше, GNU g++ 3.x, 4.x и выше.
                Чтобы изменить умолчание, надо добавить в настройки
                компилятора макро:
                  _CIOS_STDSTREAM (стандартная библиотека)
                  _CIOS_OLDSTREAM (старая библиотека)

3.  Добавить в тексты программных модулей директивы:
        #include "Cbignum.h"
        #include "Cbignums.h" (для операций потокового ввода-вывода)

Максимальная скорость вычислений обеспечивается в том случае, если при
компиляции программы задано макро NDEBUG. Более подробная информация
приведена в разделах 4.6 и 5.1. Макро NDEBUG задается по умолчанию
при компиляции под Visual C++ в режиме Release; если компиляция ведется
по командной строке, то макро можно задать в опциях.

Например, для компиляции программы Arifexp (раздел 2.1.1) под Linux
можно использовать следующие команды:

Отладочный режим:
   g++ Arifexp.cpp Cbignum.cpp Cbignumf.cpp Cbignums.cpp
       Ctty.cpp Exarray.cpp Gettimer.c Random3.c -o Arifexp

Рабочий режим:
   g++ -O5 -DNDEBUG Arifexp.cpp Cbignum.cpp Cbignumf.cpp Cbignums.cpp
       Ctty.cpp Exarray.cpp Gettimer.c Random3.c -o Arifexp


ПРИМЕЧАНИЕ: Настоящая версия класса приспособлена для компиляции под
            Borland C++, Microsoft Visual C++ и GNU g++ (версии 3.3
            или выше для многопоточных приложений). Если применяется
            другой транслятор, то для получения более производительного
            кода рекомендуется определить макро EXTHREAD_LOCAL как
            описано ниже.

            Для трансляции однопоточных приложений макро EXTHREAD_LOCAL
            должно содержать либо пустое значение, либо зависящий от
            транслятора префикс локальной памяти потока (обычно __thread).

            Для трансляции многопоточных приложений макро EXTHREAD_LOCAL
            должно содержать зависящий от транслятора префикс локальной
            памяти потока (обычно __thread). Убедитесь по документации,
            что применяемый транслятор поддерживает локальную память
            потока (thread local storage). Если это не так, то макро
            EXTHREAD_LOCAL определять НЕ НАДО, чтобы провести компиляцию
            приложения в режиме совместимости.

            Отметим, что программа, которая транслируется в режиме
            совместимости, может работать значительно медленнее на
            небольших числах, к примеру, Matrix в разделе 2.1.2.
            См. также раздел 4.2.4.


3.1. Объявление неограниченных чисел и штатные операции C++
-----------------------------------------------------------

1.  Длинное целое число объявляется, как
        cBigNumber num

2.  Начальные значения cBigNumber могут задаваться с помощью
    выражений, а также конструкторов присваивания числа или
    строки.

    Конструктор присваивания числа ограничен диапазоном
    чисел типа long со знаком:
        cBigNumber num = 2147483647;
    На 64-разрядных компиляторах допускается также присваивание
    констант типа i64, там, где они поддерживаются:
        cBigNumber num = 2147483648i64;
    Для присваивания i64 тип CBNL должен быть объявлен в файле
    Cbnl.h как 64-разрядный, в исходном варианте файла это
    сделано для всех компиляторов с 64-разрядным типом long
    и дополнительной для Visual C++ в 64-разрядном режиме.

    Конструктор присваивания строки не ограничивает диапазон.
    Он требует явного указания основания системы счисления в
    пределах от 2 до 16 или равного нулю. Нуль подразумевает
    десятичную, восьмеричную или шестнадцатеричную константу
    языка C, например:
        cBigNumber num ("0x80000000", 0):

    Выражения и конструкторы могут применяться для объявления
    длинных констант, например:
        const cBigNumber big_const ("2147483648", 10);

3.  Класс реализует все возможности штатной арифметики языка C++,
    включая арифметические, логические и побитовые операции,
    операции сравнения, сдвиги, а также операторы потокового
    ввода-вывода со всеми целочисленными модификаторами.
    Поддерживаются комбинированные операции над неограниченными
    числами и целыми числами со знаком. Поэтому правила обработки
    неограниченных чисел в основном совпадают с правилами
    целочисленной знаковой арифметики языка C.

* Важные особенности реализации, включая особенности операций
  над беззнаковыми (unsigned) числами и числами с плавающей
  точкой описаны в разделе 5.2.


3.2. Дополнительные операции, функции и методы
----------------------------------------------

Операции c результатом в стеке.
   cBigNumber (s,radix) Формирование числа из символьной строки s по
                        основанию radix от 2 до 16 или 0, последнее
                        подразумевает десятичную, восьмеричную или
                        шестнадцатеричную константу языка C, т.е.
                        шестнадцатеричную после префикса 0x/0X,
                        восьмеричную после 0, иначе десятичную.
   cBigAbs    (a)       Абсолютное значение a.
   cBigUnsign (a)       Беззнаковое значение a (все биты значащие).
   cBigPow    (a,b)     Возведение а в степень b.
   cBigPowMod (a,b,mod) Возведение a в степень b по модулю mod.
   cBigSqrt   (a)       Целая часть квадратного корня a.
   cBigBits   (a)       Число значащих бит в двоичном дополнительном коде a.
        Значащими считаются самый старший бит, отличный от
        знакового бита и все младшие по отношению к нему биты.
        Например, у 0 и -1 нет значащих битов, 1 и -2 имеют
        1 значащий бит, числа 127 и -128 имеют 7 значащих бит.
        Модуль числа с n значащими битами не больше 2 в степени n.
   cBigExBits (a)       Число значащих младших 0-бит в двоичном коде a.
        К младшим 0-битам относятся все значащие биты, младшие
        по отношению к младшему ненулевому биту.
        Например, у 0 и всех нечетных чисел нет младших 0-битов,
        2 и -2 имеют 1 младший 0-бит, 128 и -128 имеют 7 младших 0-битов.
        Модуль числа с n младшими 0-битами не меньше 2 в степени n.
   cBigRandom (rand,n)  Случайное число с числом значащих бит до n.
        Для формирования случайного числа используется внешний
        генератор rand без параметров, возвращающий случайное
        число без знака с равномерным распределением в диапазоне
        0..ULONG_MAX. Инициализируйте генератор, как описано в
        его документации. Для примера см. файл Random3r.txt.

Операции с результатом в стеке и сохранением остатка в 1-ом аргументе.
   cBigDivMod (a,b)     Целочисленное деление a/b, остаток заносится в а.
   cBigSqrtRm (a)       Целая часть квадратного корня a, остаток в а.

Консольные потоки и методы.
   cBigNumberMessages   Поток консольных сообщений.
   cBigNumberProgress   Поток консольных прогресс-индикаторов.
        Здесь потоки - это объекты класса cTTY, которые задействуются
        различными методами и функциями для вывода на консоль.
        В поток можно вывести оператором << символы, строки и числа
        с знаком, включая неограниченные числа cBigNumber. Имеются
        методы для форматированного вывода (см. файл Cttyr.txt).

   ВНИМАНИЕ:   По умолчанию, вывод на консоль отключен. Чтобы его
               включить, надо добавить в проект исполняемый файл
               Ctty.cpp и присвоить потокам обработчики:
                        cBigNumberMessages = cTTY_StandardOutput;
                        cBigNumberProgress = cTTY_ProgressOutput;

   ПРИМЕЧАНИЕ: Поскольку это глобальные переменные, присваивайте
               им обработчики только в основном потоке программы.

   a.dump     ()        Шестнадцатеричный вывод массива слов на cout
                        в порядке от старших слов к младшим.
   a.info     ()        Короткий дамп со старшим словом и числом слов.
   a.erange   ()        Сообщение "cBigNumber value out of range" с
                        коротким дампом и завершением по abort().

   ПРИМЕЧАНИЕ: Данные методы ничего не выводят, если не был
               установлен обработчик cBigNumberMessages.

Доступ к машинному представлению числа.
   a.length   ()        Число слов типа CBNL в дополнительном коде.
   a.code     ()        Массив слов типа CBNL с дополнительным кодом,
                        младшее слово имеет индекс 0.
        Метод code() выдает константный указатель, который действителен
        до тех пор, пока над числом не выполняются арифметические
        операции или операции распределения памяти.
        Для доступа к коду по записи преобразуйте указатель в CBNL*.

        Чтобы изменить число слов, запишите его в элемент с индексом -1.
        Число слов можно уменьшать до 1 или увеличивать в пределах
        распределенного под число участка памяти (см. раздел 3.3).
        Для лучшей производительности рекомендуется нормализовать
        код так, чтобы он имел минимально необходимое число слов.
        Нормализацию можно обеспечить вызовом метода fit(). Пример
        кода см. в разделе 5.2.

        ПРИМЕЧАНИЕ: Число со значением 0 может состоять из 1-го
                    слова со значением 0 или из 0 слов.

   a.fit      ()        Нормализация.
        Нормализация состоит в удалении лишних нулевых или единичных
        старших слов. Она не нужна для чисел полученных исключительно
        методами класса, т.к. все они нормализованы. Отметим, что
        ненормализованные числа корректно обрабатываться всеми методами
        класса, но полученный таким образом результат не обязательно
        будет нормализованным.

        ПРИМЕЧАНИЕ: 0 имеет две нормализованные формы - стандартную из
                    1-го слова и компактную из 0 слов (компактная форма
                    позволяет не распределять динамическую память).
                    Метод fit() преобразует компактный 0 в стандартный.

   a.loword   ()        Младшее CBNL слово дополнительного кода.
   a.hiword   ()        Старшее CBNL слово дополнительного кода.
        Оба метода работают для числа 0 из 0 слов, возвращая 0.
        Метод hiword() выдает старшее слово кода без учета нормализации
        числа т.е. если в коде есть лишние 0 или ~0 слова, то выдается
        соответственно 0 или ~0.
   a.words    ()        Число значащих слов в дополнительном коде.
        Значащими считаются самое старшие слово, содержащее не
        только знаковый бит и биты его расширения и все младшие
        по отношению к нему слова.
   a.exwords  ()        Число значащих младших 0-слов в дополнительном коде.
        К младшим 0-словам относятся все значащие слова,
        младшие по отношению к младшему ненулевому слову.
        Если все слова нулевые, то младших 0-слов нет.

Информация о числе с проверкой диапазона.
   a.bits     ()        Число значащих бит в двоичном дополнительном коде.
   a.exbits   ()        Число значащих младших 0-бит в двоичном коде.
        Методы выдают значение типа CBNL, если число бит > CBNL_MAX,
        то после диагностики вызывается abort().

Преобразование числа с проверкой диапазона.
   a.toCBNL   ()        Преобразование в целое число типа CBNL.
   a.tolong   ()        Преобразование в целое число типа long.
   a.toint    ()        Преобразование в целое число типа int.
   a.toshort  ()        Преобразование в целое число типа short.
        Если число не помещается, то после диагностики вызывается abort().

Преобразование числа в строку.
   a.toa (str)          Формирование десятичного представления числа.
   a.toa (str,radix)    Формирование символьного представления числа
                        с основанием radix в пределах от 2 до 16.
   Здесь str - объект класса cBigString, который автоматически
   преобразуется в const char*, например:
        cBigString str;
        a.toa (str);
        cout << str;
   Метод toa() возвращает char* на содержимое объекта cBigString.
   Указатель актуален, пока объект cBigString не изменяется, например:
        cBigString str;
        cout << a.toa (str);

Исключенный нереентерабельный метод (не применяйте).
   a.toatmp   ()        Формирование десятичного представления числа
                        в статическом буфере (*).
   a.toatmp   (radix)   Формирование символьного представления числа
                        в статическом буфере (*) с основанием radix
                        в пределах от 2 до 16.
(*) Статический буфер перетирается при каждом вызове toatmp().

   ПРИМЕЧАНИЕ: Данный метод недоступен, если в файле Cbignum.h включено
               макро _CBIGNUM_MT и не включено макро _CBIGNUM_TOATMP,
               что сделано по умолчанию начиная с версии класса 1.2c.
               Замените этот метод на метод toa().


3.3. Функции и методы для ручной оптимизации программ
-----------------------------------------------------

Сравнение.
   a.comp     (b)       0 при a == b; -1 при a < b; 1 при a > b
   a.comp     ()        0 при a == 0; -1 при a < 0; 1 при a > 0

Операции с накоплением результата.
   a.neg      ()        Обращение знака.
   a.add      (b)       Быстрое сложение  (*).
   a.sub      (b)       Быстрое вычитание (*).
   a.mul2     ()        Умножение на 2.
   a.div2     ()        Деление на 2 (целая часть).
   a.pow2     ()        Возведение в квадрат.
   a.pow      (b)       Возведение в степень.
   a.powmod   (b,mod)   Возведение в степень по модулю mod.
   a.sqrt     ()        Целая часть квадратного корня.
(*) Оптимизированы для операнда размером не менее 3 слов и
    аккумулятора размером не меньше операнда. То же что += и -=.

Комбинированные операции с накоплением результата.
   c.addmul   (a,b)     Умножение с накоплением c += a * b.
   c.submul   (a,b)     Умножение с накоплением c -= a * b.

Операции с присваиванием результата переменной c.
   c.set      (a)       Копирование.
   c.set      (s)       Формирование числа по десятичному представлению
                        в символьной строке s.
   c.set      (s,radix) Формирование числа из символьной строки s по
                        основанию radix от 2 до 16 или 0, последнее
                        подразумевает десятичную, восьмеричную или
                        шестнадцатеричную константу языка C, т.е.
                        шестнадцатеричную после префикса 0x/0X,
                        восьмеричную после 0, иначе десятичную.
   c.setneg   (a)       Обращение знака.
   c.setcompl (a)       Побитовая инверсия.
   c.setxor   (a,b)     Побитовая сумма по модулю 2.
   c.setand   (a,b)     Побитовая конъюнкция.
   c.setor    (a,b)     Побитовая дизъюнкция.
   c.setadd   (a,b)     Сложение.
   c.setsub   (a,b)     Вычитание.
   c.setmul   (a,b)     Умножение.
   c.setdiv   (a,b)     Деление (целая часть).
   c.setmod   (a,b)     Остаток от деления.
   c.setshl   (a,b)     Сдвиг влево.
   c.setshr   (a,b)     Сдвиг вправо.
   c.setpow   (a,b)     Степень.
   c.setpowmod(a,b,mod) Степень по модулю mod.
   c.setsqrt  (a)       Целая часть квадратного корня.
   c.setbits  (a)       Число значащих бит в двоичном дополнительном коде.
   c.setexbits(a)       Число значащих младших 0-бит в двоичном коде.
   c.setrandom(rand,n)  Случайное число с числом значащих бит до n.

Комбинированные операции с присваиванием результата переменным c и a.
   c.setdivmod(a,b)     Деление с остатком           (остаток заносится в a).
   c.setsqrtrm(a)       Квадратный корень с остатком (остаток заносится в а).

   ПРИМЕЧАНИЕ: Переменные c и a не должны перекрываться.

Комбинированные операции c применением таблицы сдвигов.
   a.tab      ()        Нормализация и формирование таблицы сдвигов.
   a.smp      ()        Нормализация и формирование таблицы сдвигов,
                        если не задействовано аппаратное умножение.

   ПРИМЕЧАНИЕ: Таблица сдвигов не мешает обычному использованию
               числа. Она остается актуальной до тех про, пока
               число не примет результат какой-либо операции.

   c.addmultab    (a,b) Умножение с накоплением c += a * b.
   c.submultab    (a,b) Умножение с накоплением c -= a * b.
                        Множимое a должно иметь таблицу сдвигов.
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата.

   ПРИМЕЧАНИЕ: Методы addmultab() и submultab() не используют блочное
               умножение, рассчитанное на большие числа и быстрое
               аппаратное умножение.

   c.addmulsmp    (a,b) Умножение с накоплением c += a * b.
   c.submulsmp    (a,b) Умножение с накоплением c -= a * b.
                        Множимое a должно быть после smp() или tab().
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата.

   ПРИМЕЧАНИЕ: Методы addmulsmp() и submulsmp() используют быстрое
               аппаратное умножение, если оно задействовано, и таблицы
               сдвигов, если аппаратное умножение недоступно. В обоих
               случаях они не используют блочное умножение, рассчитанное
               на большие числа и потому имеют меньшие накладные расходы
               на небольших числах размером не более 3000-6000 бит.
               Если хотя бы один операнд небольшой, то эти методы могут
               быть не несколько процентов быстрее addmul() и submul().

   c.setdivtab    (a,b) Деление c = a / b (целая часть).
   c.setmodtab    (a,b) Остаток c = a % b.
                        Операнды должны иметь одинаковый знак.
                        Делитель b должен иметь таблицу сдвигов
                        и не должен перекрываться с буфером результата.

   c.setdivmodtab (a,b) Деление с остатком c = a / b, a = a % b.
                        Операнды и делитель должны иметь одинаковый знак
                        и не должны перекрываться с буфером результата,
                        а также друг с другом.
                        Делитель b должен иметь таблицу сдвигов.

   ПРИМЕЧАНИЕ: Эти методы имею меньшие накладные расходы, чем общие методы
               setdiv(), setmod() и setdivmod().

Машинно-зависимые операции (зависят от размера машинного слова).
   c.set       (a,n)    Копирование c = a сдвинутое влево на n слов.
   c.setr      (a,n)    Копирование c = a сдвинутое вправо на n слов.
   c.add       (a,n)    Быстрое сложение  c += a сдвинутое влево на n слов.
   c.sub       (a,n)    Быстрое вычитание c -= a сдвинутое влево на n слов.

   c.addmultab (a,b,n)  Умножение c += a * b сдвинутое влево на n слов.
   c.submultab (a,b,n)  Умножение c -= a * b сдвинутое влево на n слов.
                        Множимое a должно иметь таблицу сдвигов.
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата.

   ПРИМЕЧАНИЕ: Методы addmultab() и submultab() не используют блочное
               умножение, рассчитанное на большие числа и быстрое
               аппаратное умножение.

   c.addmulsmp (a,b,n)  Умножение c += a * b сдвинутое влево на n слов.
   c.submulsmp (a,b,n)  Умножение c -= a * b сдвинутое влево на n слов.
                        Множимое a должно быть после smp() или tab().
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата.

   ПРИМЕЧАНИЕ: Методы addmulsmp() и submulsmp() используют быстрое
               аппаратное умножение, если оно задействовано, и таблицы
               сдвигов, если аппаратное умножение недоступно. В обоих
               случаях они не используют блочное умножение, рассчитанное
               на большие числа.

Распределение памяти.
   a.expand    (n)      Увеличить число доступных слов до оптимального
                        значения в диапазоне n..2n.

   ПРИМЕЧАНИЕ: Данная операция не изменяет число слов во внутреннем
               представлении числа. Затрагивается только число
               зарезервированных слов и только в сторону увеличения,
               т.е. если это число было изначально больше чем n,
               то оно не уменьшится.

Оптимизация использования памяти.
   a.gc        ()       Освободить избыточную память.
   a.pack      ()       Освободить всю память сверх минимально необходимой.
   a.clear     ()       Обнулить число и освободить всю выделенную память.

   ПРИМЕЧАНИЕ: Данные операции удаляют таблицу сдвигов.

Управление делением (для применения в основном потоке программы).
   cBigNumber::maskdiv0   (0)   Запретить деление на 0
   cBigNumber::maskdiv0   (1)   Разрешить деление на 0 по правилу
                                частное = 0, остаток равен делимому (*).
                                Также разрешает возведение в степень по
                                модулю 0, которое будет возвращать 1.
   cBigNumber::testdiv0   ()    Было ли деление на 0?

   ПРИМЕЧАНИЕ: Поскольку эти методы являются статическими, используйте
               их только в основном потоке программы.

Исключенные нереентерабельные методы (не применяйте).
   cBigNumber::lastdivmod ()    Последний остаток, сформированный методами
                                /, /=, setdiv, setdivtab.
   cBigNumber::lastrootrm ()    Последний остаток, сформированный методами
                                cBigSqrt, sqrt, setsqrt.

   ПРИМЕЧАНИЕ: Данные статические методы недоступны, если в файле Cbignum.h
               включено макро _CBIGNUM_MT, что сделано по умолчанию начиная с
               версии класса 1.2c. Применяйте вместо них операции cBigDivMod()
               и cBigSqrtRm() или методы setdivmod() и setsqrtrm().


3.4. Определение простых чисел и факторизация
---------------------------------------------

Базовый тест.

   b_SPRP         (a,b) Тест "строго вероятной простоты" по основанию b.
                        Выдает: 0 = составное,
                                2 = возможно, простое,

   ПРИМЕЧАНИЕ: "Строго вероятные" простые числа по основанию 2 являются
               простыми с вероятностью 99.9999%. Тем не менее, рекомендуется
               комбинировать этот тест с пробным делением (см. ниже).

Простые тесты (prime.cpp).

   SPRP           (a)   Полный тест SPRP.
   SPRP           (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (неё прошел последний тест),
                                2 = простое по начальным основаниям SPRP,
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана.

   FastSPRP       (a)   Тест SPRP для начальных оснований.
   FastSPRP       (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (не прошел последний тест),
                                2 = простое по начальным основаниям SPRP,
                                7 = возможно простое, но может быть составным.

   LastSPRP       (a)   Тест Миллера для следующих оснований.
   LastSPRP       (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (не прошел последний тест),
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана и
                                    при условии что пройден тест FastSPRP().

   ПРИМЕЧАНИЕ: Данная реализация доказывает простоту a < 341,550,071,728,321
               по тесту SPRP 2..17 и вероятную простоту для больших a
               по тесту SPRP 19..2297 и выше в зависимости от a.
               Основания до 1,373,639 простые, далее 2-3-SPRP простые.

   TestFactor     (a)   Тест факторизации по всевозможным делителям.
   TestFactor     (a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = простое.

   TestSmallFactor(a)   Тест факторизации по квадратичному и малым делителям.
   TestSmallFactor(a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = простое,
                               10 = малый делитель не найден.

   TestLargeFactor(a)   Тест факторизации по квадратичному и большим делителям.
   TestLargeFactor(a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = большой делитель не найден.

   ПРИМЕЧАНИЕ: Данная реализация использует таблицу простых чисел в
               пределах 2..7919 для a <= 62,837,329, а дальше таблицу
               факторизации для модуля 210. Квадратичный делитель и
               делители выше 7927 могут быть составными.

Комбинированные тесты в порядке от быстрых к медленным.

   IsStrongPrime  (a)   Быстрая факторизация и SPRP по начальным основаниям.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP,
                                7 = возможно простое, но может быть составным.

   IsMillerPrime  (a)   Быстрая факторизация и полный тест SPRP.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP,
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана.

   IsProvedPrime  (a)   SPRP по начальным основаниям и полная факторизация.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP.

   IsPrime        (a)   Полные тесты SPRP и факторизации с двойной проверкой.
                        Выдает: 0 = составное (найден делитель),
                                1 = нет делителя и простое по SPRP,
                        ошибка 11 - нет делителя, но составное по SPRP,
                        ошибка 12 - простое по началу SPRP, но есть делитель,
                        ошибка 13 - простое по Миллеру, но есть делитель.


4. Рекомендации по применению
=============================

Исходное техническое задание, по которому создавался класс
и пояснительная записка находятся в Приложении 1.


4.1. Возможные области применения
---------------------------------

Класс разрабатывался на основе принципа максимального упрощения
внешнего интерфейса в соответствии со стандартом языка C++ и
обеспечения совместимости с различными аппаратно-программными
платформами. Класс характеризуется низкими накладными расходами
на распределение памяти и вызов вычислительных методов, а также
отсутствием ограничений на размер чисел.

Класс может быть рекомендован для любых применений, в которых
определяющим критерием является минимизация затрат времени на
разработку программы. Производительность класса и расход памяти
будут близки к оптимальным для чисел размером от 500 до 20,000
двоичных разрядов.


4.2. Производительность
-----------------------

Наилучшие результаты по производительности получаются при
применении 64-разрядных компиляторов на 64-разрядной Windows.
64-разрядный код работает в 1.7-3 раза быстрее чем 32-разрядный
код.

Для увеличения производительности на платформе Windows следует
задействовать ассемблерную оптимизацию x386/x64, которая доступна
в виде дополнительного пакета. Ассемблерная оптимизация особенно
эффективна для процессоров AMD, где она дает 3-40-кратный рост
производительности на большинстве операций с большими числами,
включая операции накопления += и -=, умножения, деления, модуля,
возведения в степень, возведения в степень по модулю и извлечения
корня. Эффект оптимизации заметен в том случае, если слагаемое,
вычитаемое, один из множителей, делитель, результат степени или
основание корня состоит не менее чем из 3 слов. Для процессоров
Intel Core эффект оптимизации в три раза меньше - до 11-кратного,
а для процессоров Intel Pentium 4 - всего 1.5 кратный.

В последующих таблицах Arifexp с ассемблерной оптимизацией,
включенная в дистрибутив, сравнивается с C-версиями без ассемблерной
оптимизации и специальной версией Arifexp для библиотеки NTL
(http://www.shoup.net/ntl, версия 5.4).

32-разрядный код скомпилирован под Microsoft Visual C++ 6.0
в режиме Release при установках оптимизации "Maximize Speed".
Библиотека NTL компилируется с отключенным макро NTL_STD_CXX.
32-разрядный код для ARM скомпилирован под Pocket GCC 3.3.3
-O5 -DNDEBUG. Результаты получены для версии класса 1.2b,
производительность которой на обсуждаемых примерах аналогична
производительности версий 1.2с и 2.0.

64-разрядный код скомпилирован под Visual C++ Express 2010
с Microsoft SDK 7.1 x64 в режиме Release. Результаты получены
для версии 2.0.

            Время выполнения операции в миллисекундах

                    Time of computing in milliseconds

                          Test: Arif1 (+*)
CPU                             asm   NTL    C   asm64  C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)               130
ARM920T PXA312      (624 MHz)                80
Atom N270          (1600 MHz)     2     6    22
Pentium III/933     (933 MHz)     3    12    30
Pentium 4C/2400    (2400 MHz)     3     4    16
Athlon 900          (900 MHz)     2     8    28
Athlon XP 2500+    (1826 MHz)     1     4    14
Athlon 64 X2 3600+ (1900 MHz)     1     4    11
Athlon 64 X2 3800+ (2000 MHz)     1     3    10     0     8
Athlon 64 X2 4600+ (2400 MHz)     0     3     9
Phenom II X3 710   (2600 MHz)     0     2     8     0     6
FX-8150            (3600 MHz)     1     1     8     0     5
Core Duo T2500     (2000 MHz)     2     4    13
Core 2 Duo E6420   (2130 MHz)     1     4    11
Core i7-950        (3200 MHz)     1     1     6     0     4

                         Test:  Arif2 (powmod)
CPU                             asm   NTL    C   asm64  C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)             62000
ARM920T PXA312      (624 MHz)             40000
Atom N270          (1600 MHz)  2235  1859  5969
Pentium III/933     (933 MHz)  2906  3494  8578
Pentium 4C/2400    (2400 MHz)  2343   906  4297
Athlon 900          (900 MHz)  1892  2123  8051
Athlon XP 2500+    (1826 MHz)   906  1047  4094
Athlon 64 X2 3600+ (1900 MHz)   890  1031  3406
Athlon 64 X2 3800+ (2000 MHz)   813   969  3172   500  1797
Athlon 64 X2 4600+ (2400 MHz)   672   828  2640
Phenom II X3 710   (2600 MHz)   603   834  2380   344  1188
FX-8150            (3600 MHz)   537   559  2285   349  1152
Core Duo T2500     (2000 MHz)  1437   844  3765
Core 2 Duo E6420   (2130 MHz)  1234   735  2937
Core i7-950        (3200 MHz)   848   307  1686   443   844

                         Test:  Arif3 (*)
CPU                             asm   NTL    C   asm64  C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)              2200
ARM920T PXA312      (624 MHz)              1400
Atom N270          (1600 MHz)    33   109   366
Pentium III/933     (933 MHz)    55   214   494
Pentium 4C/2400    (2400 MHz)    45    64   245
Athlon 900          (900 MHz)    29   135   469
Athlon XP 2500+    (1826 MHz)    14    66   230
Athlon 64 X2 3600+ (1900 MHz)    12    61   189
Athlon 64 X2 3800+ (2000 MHz)    11    56   175     3   127
Athlon 64 X2 4600+ (2400 MHz)     9    48   147
Phenom II X3 710   (2600 MHz)     8    44   133     2    95
FX-8150            (3600 MHz)     7    27   137     3    91
Core Duo T2500     (2000 MHz)    28    70   217
Core 2 Duo E6420   (2130 MHz)    23    70   175
Core i7-950        (3200 MHz)    17    21   104     6    67

                         Test:  Arif4 (/)
CPU                             asm   NTL    C   asm64  C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)             17000
ARM920T PXA312      (624 MHz)              9000
Atom N270          (1600 MHz)   570   561  1242
Pentium III/933     (933 MHz)   970  1056  2005
Pentium 4C/2400    (2400 MHz)   611   278   981
Athlon 900          (900 MHz)   543   705  1729
Athlon XP 2500+    (1826 MHz)   263   345   900
Athlon 64 X2 3600+ (1900 MHz)   264   305   758
Athlon 64 X2 3800+ (2000 MHz)   236   298   697   141   358
Athlon 64 X2 4600+ (2400 MHz)   195   256   581
Phenom II X3 710   (2600 MHz)   161   233   479    91   211
FX-8150            (3600 MHz)   126   146   478    90   205
Core Duo T2500     (2000 MHz)   359   241   786
Core 2 Duo E6420   (2130 MHz)   313   205   606
Core i7-950        (3200 MHz)   218    89   347   121   155

                         Test:  Arif5 (sqrt)
CPU                             asm   NTL    C   asm64  C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)             32000
ARM920T PXA312      (624 MHz)             12000
Atom N270          (1600 MHz)  2922 23562  3125
Pentium III/933     (933 MHz)  2360 44453  4453
Pentium 4C/2400    (2400 MHz)  1531 11312  1891
Athlon 900          (900 MHz)  1312 27380  4376
Athlon XP 2500+    (1826 MHz)   656 13391  2141
Athlon 64 X2 3600+ (1900 MHz)   484 13088  1594
Athlon 64 X2 3800+ (2000 MHz)   453 12046  1469   234   750
Athlon 64 X2 4600+ (2400 MHz)   391 10031  1234
Phenom II X3 710   (2600 MHz)   364 10278  1140   203   563
FX-8150            (3600 MHz)   396  5898  1094   321   512
Core Duo T2500     (2000 MHz)  1062  9826  1844
Core 2 Duo E6420   (2130 MHz)  1141  8548  1422
Core i7-950        (3200 MHz)   745  3658   960   390   408

Ассемблерный пакет имеет ограниченную поддержку компиляторов
Linux из-за различий во встроенном ассемблере. К настоящему
времени он поддерживает аппаратное 32/64 разрядное умножение
с применением ассемблерной команды MUL.


4.2.1. Оптимальная разрядность
------------------------------

В 32-разрядном режиме все операции могут проводится над числами
размером до 12,800,000,000 бит при условии наличия оперативной
памяти, достаточной для представления исходных данных, результата
и (для некоторых операций) их рабочих копий. Квадратный корень
лимитирован размером CBNL_MAX = 2,147,483,647 бит в 32-разрядном
режиме. Показатель сдвига должен быть в пределах -CBNL_MAX..CBNL_MAX.

Операции сложения, вычитания, умножения, возведения в степень,
сдвига, ввода-вывода, а также побитовые и логические операции
оптимизированы для любых максимальных размеров операндов.
Накладные расходы на умножение минимизированы для случая,
когда размер хотя бы одного из операндов не менее 500 бит.
Для оптимального выполнения остальных операций достаточно,
чтобы размер результата был не менее 200-500 бит.

Операции деления, модуля и возведения в степень по модулю
оптимизированы для делителей размером от 500 до 16,000,000 бит
в 32-разрядном режиме. Наилучшие показатели обеспечиваются при
размере делителя до 1/32 размера кэш-памяти процессора; для кэша
512 Кбайт оптимальный размер делителя будет до 120,000 бит.
В 64-разрядном режиме соответствующие границы уменьшаются
в 2 раза: от 500 до 8,000,000 бит, лучше до 1/64 размера кэша,
т.е. до 60,000 бит для кэша 512 Кбайт.

Операция вычисления квадратного корня оптимизирована для операндов
размером до удвоенной кэш-памяти процессора.


4.2.2. Оценки производительности
--------------------------------

Оценки производительности даются для 32/64-разрядной ассемблерной
оптимизации при выполнении под процессорами AMD Phenom/Athlon/
Sempron, которые в рассматриваемой задаче обеспечивают более
высокую производительность, чем процессоры Intel.

ПРИМЕЧАНИЕ: Ассемблерный дополнительный пакет не включен
            в свободно распространяемую версию класса.

Оценки для 32-разрядного режима
-------------------------------

Операции сложения, вычитания, сдвига, а также побитовые и
логические операции требуют от 1/2 до 1/5 машинного такта на
получение каждого двоичного разряда результата, если размер
результата больше 200 бит. Оптимизированные операции += и -=
тратят на получение одного разряда около 1/15 машинного такта,
если размер результат больше 500 бит.

Число машинных тактов для умножения при разрядности хотя бы
одного числа от 1,000 бит может быть грубо оценено как
m * n / 200, где m и n - число битовых разрядов в числах,
округленное вверх до кратного 32. Расходы дополнительно снижаются
по методу Карацубы: если размер обоих чисел 1,600 бит или больше,
то оценка делится на 4/3 в степени log2 (n / 2000), где n - число
битовых разрядов в меньшем числе.

Число машинных тактов для деления чисел при разрядности делителя
от 2,000 бит до 1/32 размера кэш-памяти процессора может быть грубо
оценено как (m - n) * n / 30, где m и n - число битовых разрядов
соответственно в делимом и делителе.

Для вычисления квадратного корня аналогичная грубая оценка
составляет n * n / 120, где n - разрядность числа.

Оценка для ввода и преобразования строки составляет n * n / 400,
при разрядности числа до 100,000 бит. Для больших чисел оценка
делится на 4/3 в степени log2 (n / 20000).

Оценка для вывода и преобразования в строку составляет n * n / 75.

Оценки для 64-разрядного режима
-------------------------------

Операции сложения, вычитания, сдвига, а также побитовые и
логические операции требуют от 1/4 до 1/10 машинного такта на
получение каждого двоичного разряда результата, если размер
результата больше 400 бит. Оптимизированные операции += и -=
тратят на получение одного разряда около 1/25 машинного такта,
если размер результат больше 1000 бит.

Число машинных тактов для умножения при разрядности хотя бы
одного числа от 2,000 бит может быть грубо оценено как
m * n / 800, где m и n - число битовых разрядов в числах,
округленное вверх до кратного 32. Расходы дополнительно снижаются
по методу Карацубы: если размер обоих чисел 3,200 бит или больше,
то оценка делится на 4/3 в степени log2 (n / 4000), где n - число
битовых разрядов в меньшем числе.

Число машинных тактов для деления чисел при разрядности делителя
от 4,000 бит до 1/64 размера кэш-памяти процессора может быть грубо
оценено как (m - n) * n / 50, где m и n - число битовых разрядов
соответственно в делимом и делителе.

Для вычисления квадратного корня аналогичная грубая оценка
составляет n * n / 200, где n - разрядность числа.

Оценка для ввода и преобразования строки составляет n * n / 1200,
при разрядности числа до 200,000 бит. Для больших чисел оценка
делится на 4/3 в степени log2 (n / 40000).

Оценка для вывода и преобразования в строку составляет n * n / 125.

Прочие оценки
-------------

Число длинных операций для вычисления степени и степени по модулю
пропорционально размеру показателя в битах. Оценка для возведения
в степень по модулю равна n * m * m / 17 для 32-разрядного режима
и n * m * m / 28  для 64-разрядного режима, где n - число битовых
разрядов в показателе степени, m - число битовых разрядов в модуле.

ПРИМЕЧАНИЕ: Степень основана на длинных умножениях, а степень
            по модулю - на парах умножение-деление. Деление
            медленнее, поэтому оно определяет производительность
            операции в целом.

Алгоритм определения простого числа IsStrongPrime() доказывает
простоту чисел, меньших 341,550,071,728,321 за время меньше одной
миллисекунды. Для больших чисел выдает алгоритм выдает
вероятностный результат с достоверностью порядка 99,99999999%.
Время полной проверки пропорционально n в степени 3, где n - число
битовых разрядов в числе.

Более строгий алгоритм, IsMillerPrime() доказывает простоту чисел
любого размера при условии, что верна обобщенная гипотеза Римана.
Для близких по размеру чисел алгоритм работает примерно в 100 раз
медленнее, а для чисел большего размера время полной проверки растет
пропорционально n в степени 5, где n - число битовых разрядов в числе.


4.2.3. Технические особенности реализации
-----------------------------------------

При оптимизации программ следует учитывать следующие отличия
реализации неограниченных чисел от реализации встроенной арифметики
языка C++:

1.  При выполнении операций присваивания +=, -=, *=, /=, %=
    и т.п. обеспечивается более высокая производительность,
    (до 20% на коротких числах) чем при выполнении операций
    с конструированием временных объектов: +, -, *, /, % и т.п.
    По этой же причине префиксный инкремент и декремент
    работают быстрее, чем постфиксные варианты этих операций.

2.  Компилятор не проводит автоматическую оптимизацию операций
    с неограниченными числами и числовыми константами. В частности,
    не производится автоматическая замена сложения и вычитания 1
    на инкремент и декремент, а умножения и деления на степень
    двойки - на сдвиг. Тем не менее, умножение на степень двойки
    оптимизировано и выполняется так же быстро, как сдвиг влево -
    в отличие от деления на степень двойки, которое значительно
    медленнее сдвига вправо.

3.  Некоторые оптимизации можно отключить путем выключения следующих
    макро из Cbignumf.h:

    _CBIGNUM_HARDWARE_CBR   Использовать аппаратное сложение/
                            вычитание/сдвиг с переносом/займом.

    ПРИМЕЧАНИЕ: Операции с переносом применялись начиная с ранних
                версий класса и окончательно реализованы в версии 1.2.
                На современных процессорах Athlon/Core они примерно
                в 5 раз быстрее альтернативного С++ кода, но в отличие
                от него являются аппаратно зависимыми и реализованы не
                для всех компиляторов (см. раздел 1.1). Поэтому они
                включены в дополнительный ассемблерный пакет, а не в
                свободно распространяемую версию класса.

    _CBIGNUM_HARDWARE_MUL   Использовать аппаратное умножение.

    ПРИМЕЧАНИЕ: Аппаратное умножение задействовано в версии 1.2a.
                На современных процессорах Athlon/Core оно примерно
                в 5-15 раз быстрее альтернативного битового умножения
                (в зависимости от применения в последнем аппаратных
                операций с переносом или заменяющего их С++ кода),
                но является аппаратно зависимым и реализовано не для
                всех компиляторов (см. раздел 1.1). Поэтому аппаратное
                умножение включено в дополнительный ассемблерный пакет,
                а не в свободно распространяемую версию класса.

    _CBIGNUM_HARDWARE_DIV   Использовать аппаратное деление.

    ПРИМЕЧАНИЕ: Аппаратное деление задействовано в версии 1.2c для
                чисел с одним значащим словом. Оно по умолчанию
                отключено, т.к. эффект на большинстве процессоров
                невелик, за исключением факторизации в файле
                Prime.cpp, где оно включено для 64-разрядного кода.

    _CBIGNUM_KARATSUBA_MUL  Использовать метод Карацубы, если оба
                            числа имеют размер 100 и более слов,
                            при аппаратном умножении 50 и более слов.

    ПРИМЕЧАНИЕ: Метод Карацубы реализован в версии 1.2a.
                Он относительно сложен относительно в кодировании
                и требует долгого тестирования, которое к выходу
                версии 1.2а пока еще не закончено. Поэтому он
                включен в версию 1.2а для целей раcширенного
                бета-тестирования, Если Вам нужны надежные
                вычислению, то этот метод лучше отключить.

    _CBIGNUM_BLOCK_MUL      Использовать блочное умножение, если
                            оба числа имеют размер 715 и более слов.

    ПРИМЕЧАНИЕ: Блочный метод реализован в версии 1.0 для того,
                выполнять умножение в кэше L1 процессора. Теперь
                он заменяется более эффективным методом Карацубы,
                кроме случая, когда одно из чисел короче 100 слов,
                при аппаратном умножении 50 слов.

    _CBIGNUM_TERNARY_MUL    Использовать ускоренный на 30% троичный
                            метод умножения с таблицей сдвигов
                            вместо более простого двоичного.

    ПРИМЕЧАНИЕ: Троичный метод реализован в версии 1.2. Теперь
                двоичный и троичный методы заменяется более
                эффективным аппаратным умножением, если оно
                задействовано.

    _CBIGNUM_SHIFTTAB_MUL   Строить временные таблицы сдвигов
                            для ускорения умножения, если оба
                            числа имеют размер 3 и более слов.

    ПРИМЕЧАНИЕ: Таблицы сдвигов реализованы в версии 1.0.
                Теперь они заменяются более эффективным аппаратным
                умножением, если оно задействовано.

    _CBIGNUM_SHIFTTAB_DIV   Строить временную таблицу сдвигов
                            для ускорения деления и модуля,
                            если делимое имеет на 3 или более
                            слова больше, чем делитель, но не
                            более примерно 64M слов.

    ПРИМЕЧАНИЕ: Деление с таблицей сдвигов реализовано в версии
                1.0.

    _CBIGNUM_REDUCE_JUMPS   Использовать дополнительные операции
                            для сокращения числа условных переходов.

    ПРИМЕЧАНИЕ: Реализовано в версии 1.2c для деления чисел с одним
                значащим словом. По умолчанию выключено, потому что
                неэффективно на популярных микропроцессорах.

4.  Комбинированные методы с таблицей сдвигов позволяют ускорить
    выполнение многократных операций с одним и тем же множимым
    или делителем, поскольку позволяют строить таблицу сдвигов
    только один раз. Кроме того, эти методы не проводят внутреннее
    копирование операндов в предположении, что операнды не
    перекрываются.

    Комбинированное умножение с таблицей сдвигов addmultab() и
    submultab() эффективно только в том случае, если недоступно
    быстрое аппаратное умножение. Оптимальный размер множимого
    в пределах в пределы от 500 битов до 6,000 битов; множимое
    может быть короче 500 битов, если оно длиннее множителя и
    множитель не короче 100 битов. Если размер операндов
    существенно выходит за указанные пределы, то целесообразнее
    использовать обычное умножение, т.к. его производительность
    будет выше благодаря применению блочных методов оптимизации.

    Комбинированное умножение addmulsmp() и submulsmp() эффективно
    и в том случае, если задействуется быстрое аппаратное умножение,
    прочие условия эффективности те же, что для умножения с
    таблицей сдвигов. Ускорение составляет несколько процентов
    за счет исключения внутренних операций копирования.

    Комбинированное деление м модуль с таблицей сдвигов эффективны
    при любых размерах делителя.

5.  В реализации умножения, деления, модуля, степени и возведения
    в степень по модулю предусмотрена встроенная оптимизация для
    чисел, кратных большой степени двойки (~100 и выше).

6.  Передача неограниченного числа в функцию по ссылке проводится
    быстрее, чем передача по значению, т.к. в последнем
    случае производится копирование объекта. Если функция не
    модифицирует значение параметра, то передачу по значению
    рекомендуется заменить на передачу по константной ссылке:
        const cBigNumber&

7.  Создание и удаление локальных неограниченных чисел, определенных
    внутри функций и блоков, занимает примерно столько же
    времени, что и выполнение 2-3 коротких арифметических
    операций. Выносите локальные определения неограниченных чисел
    за пределы критических по времени циклов. Если не важна
    реентерабельноcть кода, то вместо этого можно добавить
    ключевое слово static и провести инициализацию в отдельном
    операторе присваивания:
        cBigNumber a = 1;            // Локальное определение
        static cBigNumber a; a = 1;  // Оптимизация

8.  Вывод очень длинного целого числа (> 100,000 цифр) в
    десятичном формате может занять много времени. Несколько
    быстрее (в 5 раз) вывод в шестнадцатеричном формате,
    но он тоже может быть очень медленным. Самая быстрая
    распечатка числа в шестнадцатеричном представлении
    выполняется методом dump().


4.2.4. Поддержка многопоточных приложений
-----------------------------------------

Полноценная поддержка многопоточности введена в версии 1.2c,
для чего в файле Cbignum.h установлено макро _CBIGNUM_MT.

Макро _CBIGNUM_MT исключает нереентерабельные статические методы
lastdivmod(), lastrootrm(). Замените их на реентерабельные операции
cBigDivMod(), cBigSqrtRm() или методы setdivmod(), setsqrtrm().
Также исключается нереентерабельный метод toatmp(), если только не
установлено макро _CBIGNUM_TOATMP, замените его на метод toa().

ПРИМЕЧАНИЕ: Если программа компилируется в режиме совместимости
            на трансляторе, не поддерживающем локальную память
            потока (см. раздел 3), то макро _CBIGNUM_MT замедляет
            бинарные операции, создающие временные объекты:
            +, -, *, /, % и т.п.

            Если Вам не требуется поддержка многопоточности, то
            можно уделить макро _CBIGNUM_MT, тогда будет включена
            более скоростная нереентерабельная реализация. Это
            особенно полезно при операциях над короткими числами,
            которые будут выполняться в 3 раза быстрее.
            Другое решение - использовать операции присваивания
            +=, -=, *=, /=, %= и т.п., производительность которых
            не зависит от макро _CBIGNUM_MT.


4.3. Расход памяти
------------------

С точки зрения расхода памяти, класс оптимизирован для чисел
размером свыше 500 бит в 32-разрядном режиме и свыше 1000 бит
в 64-разрядном режиме. В этом случае объем выделенной памяти
будет в среднем на 37.5% больше минимально необходимого.

Дополнительная оптимизация может быть достигнута при соблюдении
следующих правил:

1.  Для хранения коротких значений следует применять числа long
    или CBNL, которые во всех операциях можно свободно комбинировать
    с числами cBigNumber.

2.  Для своевременного удаления больших чисел размещайте их в
    локальных переменных. При использовании для этой цели глобальных
    и статических переменных следует учитывать, что по соображениям
    оптимизации в классе не предусмотрено автоматическое освобождение
    избыточной памяти, выделенной для хранения неограниченных чисел.

3.  Начиная с версии 2.0 класс не выделяет память для чисел в
    конструкторе по умолчанию, что позволяет экономить память,
    выделяемую под разреженные массивы (т.е. массивы, в которых
    большинство элементов равны 0). Чтобы эта экономия состоялась,
    не следует явным образом инициализировать элементы разреженных
    массивов 0, потому что явное присваивание любого, в том числе
    и нулевого значения приводит к выделению памяти, например:

    cBigNumber a [1000];                // Массив, заполненный 0.
    for (i = 0; i < 1000; i++) {        // Выделяется примерно 25
      a [i] = 0;                        // машинных слов для каждого
    }                                   // элемента массива.

    Эту оптимизацию можно отключить путем включения следующего
    макро из Cbignum.h:

    _CBIGNUM_DEF_ALLOC      выделять память в конструкторе по
                            умолчанию, как в версиях 1.x класса.

4.  Для освобождения избыточной памяти предусмотрен метод gc().

    * Метод gc() оптимизирован с точки зрения уменьшения фрагментации
      динамической памяти. Он оставляет зону расширения, составляющую
      в среднем 37.5% от размера числа, кроме небольших чисел, т.к.
      итоговый размер числа будет не меньше 104 байт в 32-разрядном
      режиме и не меньше 224 байт в 64-разрядном режиме. Исключением
      является нормализованный 0, для которого метод gc() освобождает
      всю распределенную динамическую память, если не установлено
      макро _CBIGNUM_DEF_ALLOC.

    * Метод gc() не проводит предварительную нормализацию числа.

5.  Максимальное освобождение памяти достигается при применении
    метода pack().

    * Метод pack() сокращает размер числа до минимума, определяемого
      исключительно разрядностью числа. Зона расширения при этом
      удаляется, а в динамической памяти остается только минимально
      необходимая служебная информация размером в 2 слова типа CBNL
      и собственно двоичный код числа. А для нормализованного 0 метод
      pack() освобождает всю распределенную память, если не установлено
      макро _CBIGNUM_DEF_ALLOC.

    * Метод pack() не проводит предварительную нормализацию числа.

    * Состояние упаковки не сохраняется при присваивании упакованного
      значения и передачи его в функцию по значению, т.к. эти операции
      выполняются путем копирования кода числа в новый объект.

    * Упакованная переменная автоматически распаковывается при
      выполнении модифицирующей операции, если требуется выделить
      дополнительную память.

    * В существующей реализации при применении метода pack()
      возрастает фрагментация динамической памяти, что может
      привести к падению производительности.

6.  Для обнуления числа и освобождения памяти можно использовать
    метод clear(), который аналогичен gc() после присваивания 0.


4.4. Взаимодействие с операционной системой
-------------------------------------------

Класс не ограничивает размерность чисел, для чего реализовано
автоматическое распределение памяти. В зависимости от размера
формируемых алгоритмом чисел, объем затребованной памяти может
привести к исчерпанию системных ресурсов и резкому замедлению
работы операционной системы. Поэтому в ответственных случаях
следует ограничивать максимальный объем оперативной памяти,
выделяемой программе.


4.5. Предупреждение ошибок
--------------------------

Внешний интерфейс класса построен в максимально точном соответствии
с соглашениями языка C++ (детали уточняются в разделе 5), поэтому
программистам следует обращать внимание в основном на соблюдение
общих правил безопасного программирования на языке C++:

1.  При применении операторов присваивания внутри выражений следует
    учитывать, что порядок выполнения выполнения операций не
    зафиксирован.

2.  При вводе чисел рекомендуется явным образом задавать основание
    системы счисления модификаторoм dec, oct или hex. Иначе основание
    будет определяться автоматический в зависимости от наличия 0
    перед числом.

3.  При применении оптимизированных методов следует соблюдать все
    оговоренные в их описании ограничения. В частности, некоторые
    оптимизированные методы не допускают, чтобы их операнды
    перекрывались.


4.6. Встроенные средства предупреждения ошибок
----------------------------------------------

Все методы класса включают в себя средства предупреждения внутренних
ошибок, которые по своему назначению делятся на два класса:

1.  Средства диагностики ошибок включаются при компиляции в отладочном
    режиме. Данные средства предназначены для выявления особых ситуаций,
    при которых увеличивается вероятность появления так называемых
    нерегулярных ошибок. В частности, отслеживаются ситуации выхода
    индекса за границу массива, нарушения внутренних инвариантов и т.п.
    При срабатывании средств диагностики выдается assert-сообщение и
    работа программы прекращается.

    ПРИМЕЧАНИЕ: При необходимости отключения контроля индексов на этапе
                отладки программы проведите компиляцию с макро NCHECKPTR.

                Кроме того, можно отключить контроль индексов только
                для входных (const) массивов путем компиляции с макро
                _CBIGNUM_NCHECKPTR.

2.  Средства коррекции ошибок включаются при компиляции программы
    в рабочем режиме с макро NDEBUG. Эти средства достаточно эффективны
    в том плане, что они нейтрализуют последствия ряда распространенных
    скрытых ошибок, в том числе некоторых ошибок переполнения буфера.

Благодаря наличию средств коррекции, активизация средств диагностики
на этапе отладки программы никоим образом не свидетельствует о том,
что в рабочем режиме методы класса будут работать неправильно. Тем не
менее, некоторая вероятность некорректной работы все таки существует,
поэтому обо всех случаях такого рода следует сообщить автору класса.

ПРИМЕЧАНИЕ: Средства предупреждения ошибок отлавливают до 70%
            всех внутренних ошибок, но некоторые ошибки все таки
            могут остаться незамеченными, в особенности если речь
            о вновь реализованных алгоритмах. Поэтому предусмотрена
            возможность отключить новые алгоритмы и использовать
            вместо них старые, лучше отлаженные версии кода.
            Возможности такого рода описаны в разделе 4.2.3.


5. Технические сведения
=======================

Данный раздел содержит технические сведения о текущей реализации
класса без предоставления гарантий относительно того, что все
сведения будут справедливы для последующих версий класса.


5.1. Сведения о реализации
--------------------------

В основу класса cBigNumber положен шаблон динамических массивов
Exarray.h, выполняющий распределение оперативной памяти.
В этом же файле находится шаблон ограниченных указателей exptr,
который применяется в файле Cbignumf.cpp для организации
контроля индексов на этапе отладки программы.

Для отключения контроля индексов следует задать макро NDEBUG или
NCHECKPTR. Макро NDEBUG задается по умолчанию при компиляции под
Visual C++ в режиме Release.

Контроль индексов, если он включен, замедляет работу методов
класса примерно на 150-400 процентов, но зато все некорректные
обращения к памяти отлавливаются так же надежно, как в Яве и С#.
При этом можно пользоваться безопасной арифметикой над указателями,
чего нет ни в Яве, ни даже в C#.


5.2. Особенности реализации штатных операций
--------------------------------------------

Операции над неограниченными числами проводятся по штатным
правилам языка С с использованием всех штатных операторов.
Особенности класса обусловлены ограничениями языка C++:

1.  Операция sizeof выдает размер дескриптора неограниченного
    числа (объекта cBigNumber), а не размер внутреннего
    представления числа в байтах.
    Размер внутреннего представления неограниченного числа
    в словах типа CBNL выдается методом length().
    Размер неограниченного числа в байтах равен произведению
    length() * sizeof (CBNL).

2.  Операция & выдает указатель дескриптора неограниченного
    числа (объекта cBigNumber), а не указатель внутреннего
    представления числа в памяти. Указатель внутреннего
    представления неограниченного числа в словах типа CBNL
    выдается методом base().

3.  При выполнении операций над неограниченными числами
    целочисленное переполнение не происходит.
    При нехватке оперативной памяти для представления
    неограниченного числа вызывается функция abort().

4.  Перед присваиванием беззнакового (unsigned) числа
    неограниченному числу или выполнением операции над ними
    беззнаковое число преобразуется к типу signed CBNL по
    правилам языка С, что может привести к интерпретации
    большого положительного числа, как отрицательного.

    Чтобы сохранить беззнаковое значение при присваивании,
    можно использовать метод code():
        cBigNumber a;                   // Неограниченное число.
        unsigned CBNL n = 0xFFFFFFFFUL; // Беззнаковое число,
        {                               // значение приведено как пример.
          a.expand (2);                 // Память под два слова.
          CBNL *pa = (CBNL*) a.code();  // Указатель для модификации кода.
          pa [0] = n;                   // Присвоение числа.
          pa [1] = 0;                   // Нулевое слово для знака.
          pa [-1] = 2;                  // Число слов.
          a.fit();                      // Нормализация.
        }                               // Удаление указателя.
    Вместо вызова метода fit(), в данном случае можно использовать
    присваивание:
          pa [-1] = 1 + ((CBNL)n < 0);  // Нормализованное число слов.

5.  Перед присваиванием числа с плавающей точкой неограниченному
    числу или выполнением операции над ними плавающее число
    преобразуется к типу signed CBNL по правилам языка С, т.е.
    путем отбрасывания дробных разрядов. Если полученное
    таким образом число не помещается в разрядную сетку CBNL,
    то результат преобразования не определен.

6.  В отличие от обычных чисел, для неограниченных чисел не
    предусмотрены операции приведения типа.
    Преобразование неограниченного числа к целому числу
    проводится явным образом с помощью метода loword(),
    результатом преобразования является число типа CBNL.
    Преобразование проводится с сохранением исходного
    значения числа при условии, что значение помещается
    в диапазон значений типа CBNL.
    Для проверки диапазона достаточно убедиться в том,
    что размер внутреннего представления неограниченного числа,
    выдаваемый методом length(), не больше равен 1:
      if (bignum.length() <= 1) num = bignum.loword();
      else ... /* ошибка */

    Для преобразования с поверкой диапазона можно применить
    методы toCBNL(), tolong(), toint() and toshort().

7.  Для исключения конфликта имен с библиотекой math.h
    функция возведения в степень названа cBigPow.

8.  Возведение в отрицательную степень интерпретируется,
    как возведение обратной величины (1/x) в положительную
    степень, при этом дробная часть обратной величины
    отбрасывается. Таким образом, результат будет следующим:
    ошибка деления для основания 0, 1 для основания 1 и
    0 для любого основания большего 1.

9.  Отрицательный показатель сдвига интерпретируется, как
    смена направления сдвига. В стандарте С результат такого
    сдвига не определен.

10. Квадратный корень отрицательного числа равен 0.

11. Начиная с версии 1.2 вывод отрицательных чисел с модификаторами
    hex и oct выполняется со знаком. Если требуется вывод без знака,
    то используйте функцию cBigUnsign() или проводите трансляцию с
    макро _CBIGNUM_UNSIGN_OCT_HEX.


Приложение 1: Пояснительная записка к работе на конкурс SofTool'99
==================================================================

                   Задача 1 (фирма Aladdin)

Написать класс C++ cBigNumber, позволяющий работать с целыми
числами произвольной длины. Реализовать перегруженные операторы
сложения, вычитания, умножения, целочисленного деления,
получения остатка от деления, возведения в степень.
Аргументами операторов могут быть объекты cBigNumber и
обычные целые числа (int).

Реализовать функцию ввода числа с клавиатуры и вывода на экран в
десятичном и шестнадцатеричном виде.

                   Пояснительная записка.

Задача сформулирована кратко, поэтому я направил в конкурсную
комиссию письмо с просьбой уточнить критерии оценки конкурсных
работ. Поскольку ответ не был получен, то был сделан вывод о
том, что все необходимые сведения содержатся в условиях задачи
в явном или неявном виде.

На основании условий задачи были cформулированы
и реализованы следующие требования:

1) Разрядность чисел и выбор алгоритмов умножения и деления.

Оптимальные алгоритмы умножения и деления существенным
образом зависят разрядности чисел; реализовать в
конкурсной работе все алгоритмы не представляется возможным.

Анализируя условия задачи, можно предположить,
что алгоритмы должны обеспечивать работу над числами любой
разрядности и при этом быть оптимальными:
 - для операций над длинным и коротким числом, т.к. эти
   операции особо оговариваются в задаче 1;
 - для операций над небольшими длинными числами
   (до 1000 бит), т.к. в задаче 2 речь идет о проверке
   простоты числа, что подразумевает небольшую разрядность.
Исходя их этого:
1. Числа представляются в дополнительном коде.
2. Для умножения и деления были выбраны
   "школьные" алгоритмы в двоичном варианте.
3. При реализации класса особое внимание уделялось снижению
   накладных расходов на вызов вычислительных методов.

Производительность класса при работе с числами, помещающимися
в пределах разрядной сетки long, составляет около 500 тысяч
арифметических операций в секунду на Pentium-166, что
примерно в 20 раз медленнее, чем встроенная арифметика.

При увеличении размера слагаемых, одного их множителей или
делимого производительность падает пропорционально размеру
чисел, при увеличении размера обоих множителей а также
делимого и делителя - пропорционально квадрату размера.

Алгоритмы тестировались на числах размером до 100,000 бит.

2) Переносимость.

Поскольку в условиях задачи не оговаривается аппаратно-
-программная платформа, а упомянут только компилятор
Visual C++, то это значит, что класс должен быть
переносимым по крайней мере между теми платформами,
для которых работают бравые парни из Microsoft
(Intel, Alpha, Strong ARM и т.п.).

Поэтому класс cBigNumber написан на стандартном C++
без применения машинно-зависимых ассемблерных
инструкций и нестандартных типов данных, таких,
как _int64. Надеюсь, что это решение создаст
хорошие предпосылки для переносимости класса.

3) Полнота реализации штатных операций языка С.

Программист, использующий класс cBigNumber,
должен иметь возможность использовать все штатные
операции языка C без каких-либо ограничений.


Приложение 2: Известные ошибки
==============================

1. Некоторые компиляторы отвергают оператор ?, если в альтернативах
   применяются различные операции, например: (a < 0? -a: a).

2. Класс не выполняет извлечение квадратных корней из чисел
   размером более CBNL_MAX бит и сдвига с показателем вне
   пределов -CBNL_MAX..CBNL_MAX бит (сообщается об ошибке
   "cBigNumber value out of range").

3. При присваивании числа C неограниченному числу или выполнении
   операции над ними число С подвергается предварительному
   преобразованию к типу long со знаком. Это преобразование не
   будет проведено корректно, если число относится к беззнаковому
   (unsigned) типу или типу с плавающей точкой и его абсолютное
   значение больше, чем CBNL_MAX.

4. По непонятной причине GNU g++ 2.9.6 строит странные программы с
   неверно работающими потоками cout и cerr, если глобальный
   cBigNumber инициализируется строковыми переменными, например,
        static const cBigNumber big_const ("2147483648", 10);

   Если Вам требуется писать переносимый код, то либо создавайте
   такие объекты локально в {} или инициализируйте их отдельно.

5. Компилятор C++ в Microsoft SDK 2003 R2 (64-bit) выдает массу
   предупреждений при работе с новой библиотекой iostream. Для
   завершения компиляции задействовать старую библиотеку по макро
   _CIOS_OLDSTREAM или выключать режим "treat warning as errors"
   (опция /WX-).


Приложение 3: Что нового
========================

15.09.1999 - работа на конкурс SofTool'99

- Реализован базовый набор арифметических операций над длинными числами.


08.10.1999 - класс размещен в Интернет.

- Отлажены методы определения простоты числа.

- Реализован ускоренный вывод больших чисел по методу двоичного дерева,

- Реализована ускоренная операция деления с применением таблицы сдвигов.


25.10.1999

- Разрешены возведение в степень и сдвиг с отрицательным показателем.

- Разрешено возведение в степень по отрицательному модулю.

- Операция деления ускорена в 2-3 раза за счет применения встроенного
  ассемблера x386 (опция). Компиляция ассемблерных инструкций
  обеспечивается в Borland C++ 4.5.

- Реализован прогресс-индикатор при выводе больших чисел (100 тыс. бит).

- ИСПРАВЛЕНО: Проблемы при компиляции в Borland C++ Builder 1.0 и
              Visual C++ 5.0, появившиеся в предыдущей версии класса.


31.10.1999

- ИСПРАВЛЕНО: Ошибка распределения памяти в методе addmul().

- Обеспечена компиляция ассемблерных инструкций в отладочном режиме.

- Отладочный контроль индексов теперь включен по умолчанию; для
  его отключения следует установить макро NDEBUG или NCHECKPTR.


12.04.2000

- Поддержка Visual C++ 6.0, кроме ассемблерных инструкций.

- Максимальный размер 32-разрядного динамического массива уменьшен
  в два раза - c 4Г до 2Г. Это потребовалось для того, чтобы обойти
  ошибку в Visual C++ 6.0: если не установлен SP3, то в режиме
  оптимизации по скорости транслятор вычисляет константные выражения
  типа (SIZE_T_MAX-4)/4 по правилам знаковой арифметики.
  Изменения затронули функции exmuladd и exmul в файле Exarray.h.
  В 16-разрядном режиме максимальный размер массива по-прежнему 64К.

- Вместо константы SIZE_T_MAX теперь применяется константа EXSIZE_T_MAX,
  задающая максимальное значение результата целочисленных вычислений
  с контролем переполнения разрядной сетки.


17.05.2000

- Новая версия шаблона Exarray.h.

- Вместо метода ptr(), исключенного из шаблона exarray,
  теперь применяется макро EXPTRTYPE.

- Макрофункции заменены на inline - функции.


05.09.2001

- Методы tolong(), toint() и toshort() для формирования
  целого числа с проверкой диапазона.


14.03.2003 - Версия 1.0 beta public

- Написана программа Arifexp и командный файл Arifrand.bat для
  тестирования методов класса на случайных примерах.

- Проведено тестирование класса на 20,000,000+ случайных примерах.

- Добавлены методы вычисления квадратного корня.

- Операции умножения и умножения с накоплением ускорены в 3-4 раза
  за счет применения таблицы сдвигов, блочного метода и (опция)
  встроенного ассемблера x386. Компиляция ассемблерных инструкций
  обеспечивается в Borland C++ 4.5.

- Новый метод addmultab() для умножения с накоплением и предварительно
  подготовленной таблицей сдвигов.

- Определены требования к памяти при делении очень больших
  чисел (до 64 Mбайт).

- Ввод больших чисел ускорен в 5 раз по методу двоичного дерева.

- Прогресс - индикатор при вводе больших чисел.

- В методе addmultab() появилась опция для указания сдвига
  на заданное число слов.

- Оптимизированные операции сдвига для Intel x386 при
  умножении, делении и вычислении квадратного корня.

- Новые методы деления с остатком setdivmod() и setdivmodtab(),
  не задействующие служебный буфер cBigNumber::lastdivmod().

- При выводе и преобразовании в строку сохраняется значение
  служебного буфера cBigNumber::lastdivmod().

- Методы gc() и pack() для освобождения памяти.

- Метод set() теперь подразумевает десятичное число по умолчанию.

- Удален метод compl(), имя которого зарезервировано в стандарте C++.

- Устраненo избыточное копирование в операторе /=.

- Сокращен перебор делителей в методе HasFactor().

- ИСПРАВЛЕНО: Две ошибки при делении отрицательного числа.

- ИСПРАВЛЕНО: Ошибка при делении, из-за которой могло быть
              получено частное с неверным знаком.

- ИСПРАВЛЕНО: Математическая ошибка при возведении в степень по
              модулю. Раньше результаты были корректными только
              в том случае, если показатель степени был меньше
              модуля.

- ИСПРАВЛЕНО: Ошибки удаления завершающего символа из потока ввода
              и возвращения метки конца файла в поток ввода.

- ИСПРАВЛЕНО: Фатальная ошибка распределения памяти при возведении
              в степень 0.

- ИСПРАВЛЕНО: Ошибка распределения памяти в методе powmod().

- ИСПРАВЛЕНО: Ошибки распределения памяти в отладочных режимах
              addmul(), tab(), оператора вывода, умножения и деления.

- ИСПРАВЛЕНО: Ошибка в отладочном режиме метода addmultab()
              и соответствующая ей некорректность в документации.

- ИСПРАВЛЕНО: Незначительные несоответствия при распределении
              памяти в методах pow(), powmod(), setshl().

- Реализован режим экономии памяти для 16-разрядных компиляторов.

- Реализовано автоматическое снижение приоритета при работе
  тестовых программ под Windows и обработка ошибок вывода.

- Обеспечена компиляция в GNU g++ 2.9.6, кроме ассемблерных инструкций.

- В дистрибутив включены тестовые программы для Linux.

- Уточнено лицензионное соглашение и дополнена документация.

- Подготовлен перевод документации на английский язык.

- Вся документация теперь размещается в одном файле.


31.03.2003 - Обновление версии 1.0 beta public

- Совместимость с Borland C++ Builder 6.0.


05.07.2003 - Версия 1.1 beta public

- Совместимость с Visual C++ 7.0.

- Комментарии к исходным кодам переведены на английский.

- Изменения в шаблоне Exarray.h.


12.09.2005 - Версия 1.1a beta public

- ИСПРАВЛЕНО: Знак результата возведения в степень по модулю теперь
              не зависит от знака модуля.
  ВНИМАНИЕ:   Проверьте, что ваши программы на зависят от этой ошибки
              в спецификации!

- ИСПРАВЛЕНО: Операция возведения в степень по модулю теперь
              корректно работает для отрицательной базы.

- ИСПРАВЛЕНО: Ошибка распределения памяти при возведении в степень
              по отрицательному модулю со старшим словом 0x80000000.

- ИСПРАВЛЕНО: Ошибка распределения памяти при возведении в степень
              по модулю 0, если разрешено деление на 0.

- ИСПРАВЛЕНО: Ошибка распределения памяти в отладочном режиме при
              умножении двух длинных (больше 480 слов) отрицательных
              чисел со старшими словами 0x80000000.

- ИСПРАВЛЕНО: Ошибка assert в отладочном режиме setdivtab(),
              setmodtab(), setdivmodtab() при делении отрицательного
              числа на 0.

- ИСПРАВЛЕНО: Операции сдвига переписывают cBigNumber::lastdivmod()
              если количество бит задано неограниченным числом.

- ИСПРАВЛЕНО: Ошибка переполнения разрядной сетки при извлечении
              квадратного корня из чисел размером более INT_MAX бит.

- ИСПРАВЛЕНО: Описание аргумента n в методе addmultab (a,b,n).

- Исправления в разделе 1.2 и дополнения в разделе 4.2.3
  документации.

- Пополнен список ошибок в Приложении 2, включая проблему с
  реентерабельностью.


28.09.2005 - Исправление версии 1.1a beta public

- ИСПРАВЛЕНО: Возведение в степень по модулю выдает 1, если старшее
              слово модуля равно 0 (спасибо Александру).

- Примеры команд для компиляции под Linux в разделе 3.


31.10.2005 - Обновление документации

- Подробнее описаны особенности выполнения операций над
  беззнаковыми числами и числами с плавающей точкой.

- Документирован метод expand() для распределения памяти.

- Более подробное описание метода code().


12.11.2005 - Обновление версии 1.1a beta public

- Ассемблерный код теперь распространяется в дополнительном пакете.

- Тестовые программы собраны под компилятором Visual C++ 6.0
  с ассемблерной оптимизацией.

- Тесты производительности для различных процессоров в разделе 4.2.

- Новые оценки производительности в разделе 4.2.2.

- ИСПРАВЛЕНО: Метод setneg() не обращает знак числа LONG_MIN.

- ИСПРАВЛЕНО: Ошибка распределения памяти в шаблоне Exarray.h.


26.11.2005 - Обновление версии 1.1a beta public

- Файлы Random.h and Random.c переименованы в Random3.h и Random3.c.

- ИСПРАВЛЕНО: Неправильная таблица факторизации в Prime.cpp (спасибо
              Nicolas).

- ИСПРАВЛЕНО: Метод b_SPRP() возвращает "возможно, простое" на четных
              числах (Nicolas).


05.09.2006 - Версия 1.2 beta internal

- Обеспечена совместимость с Visual C++ Express 2005 и другими
  трансляторами, не поддерживающими старую библиотеку iostream.h.

- Подключение библиотеки iostream теперь необходимо только для
  операторов ввода-вывода в соответствующие потоки. В частности,
  функции преобразования числа в строку и строки в число теперь
  могут применяться без подключения библиотеки iostream.

- Увеличена скорость умножения (50%) для чисел из 3 и более слов.

- Оптимизированы операции накопления += и -=. В дополнение к более
  эффективному коду C, на них также распространяется ассемблерная
  оптимизация.

- Более гибкие методы проверки на простоту с оптимизированным
  алгоритмом. SPRP() и факторизация работают примерно в 2 раза
  быстрее для модулей > 7919.

- ИЗМЕНЕНИЕ: Функция HasFactor() переименована в TestFactor().
             Чтобы вернуть имя, определите макро _CBIGNUM_HASFACTOR.

- ИЗМЕНЕНИЕ: Ненулевые коды возврата функций SPRP() и IsPrime().

- ИЗМЕНЕНИЕ: Для использования операторов потокового ввода-вывода
             надо подключить новый файл Cbignums.h. Файл Cbignums.h
             теперь не подключает библиотеку iostream.

- ИЗМЕНЕНИЕ: Вывод отрицательных чисел с модификаторами hex и oct
             теперь выполняется со знаком. Если требуется вывод без
             знака, то используйте функцию cBigUnsign() или проводите
             трансляцию с макро _CBIGNUM_UNSIGN_OCT_HEX.

- ИЗМЕНЕНИЕ: Методы и функции класса осуществляют вывод на консоль
             через специальные потоки cTTY, см. раздел 3.2.
             По умолчанию вывод отключен.

- ИЗМЕНЕНИЕ: Статические методы lastdivmod() и lastrootrm() подлежат
             исключению в версии класса 2.0. Используйте вместо
             них методы setdivmod() и setsqrtrm().

- ИЗМЕНЕНИЕ: Метод erange() выводит короткий дамп числа вместо полного.

- ИЗМЕНЕНИЕ: Метод bits() теперь возвращает значение long вместо int,
             при переполнении вызывает erange().

- Новые методы setbits(), exbits(), setexbits(), words(), exwords().

- Новые конструкторы и методы cBigAbs(), abs(), setabs(),
  cBigUnsign(), unsign(), setunsign().

- Генератор случайных чисел: конструктор cBigRandom(), метод setrandom(),
  long-функции в Random3.h и Random3.cpp.

- Новые методы submul(), submultab().

- Методы setdivtab(), setmodtab(), setdivmodtab() теперь не требуют,
  чтобы делимое было нормализованным.

- Оптимизировано умножение длинных чисел (более 480 слов) на
  короткие числа (1 или 2 слова).

- Небольшая оптимизация деления для очень длинных чисел.

- Разрешено возведение в степень чисел размером более INT_MAX бит.

- ИСПРАВЛЕНО: Реализация метода dump() зависит от разрядности процессора.

- ИСПРАВЛЕНО: Ошибки при работе с ненормализованными нулями.

- ИСПРАВЛЕНО: Маловероятные ошибки при диагностике нехватки ресурсов
              для выполнения левых сдвигов и возведения в степень.

- Новая версия программы Arifexp:
    Ключи -div0, -size, -v, -rep n, -rand 0, -rand all.
    Добавлены операции ++a, --a, a-b*c, удалены операции a+b\c, a*b%c.
    Суффикс R для подстановки случайного числа с заданным числом бит.
    Ключ -check теперь проверяет результат всех операций,
    кроме степени с показателем, отличным от 2,4,8.

- Дополнительные тесты в Arifrand.bat.

- Тест генератора случайных чисел Arifr.bat.


29.11.2006 - Версия 1.2 beta public

- Функции для проверки на простоту теперь имеют дополнительный
  выходной параметр для последнего протестированного делителя или
  основания SPRP. Если число доказано, как составное, то там будет
  делитель или не прошедшее проверку основание SPRP.

- ИЗМЕНЕНИЕ: Переименована пара функций из internal версии:
             FastExactSPRP() в FastSPRP(), PostExactSPRP() в PostSPRP().

- Опции для выбора алгоритма в программе Miller.

- Расширенное тестирование программы Miller на 1,000,000,000+ примерах.

- ИСПРАВЛЕНО: Программа сваливается после компиляции в режиме Release
              под трансляторами Microsoft Visual C++ .NET, SDK 2003 и 2005
              с опцией /Ob2 (auto inline).


30.04.2007 - Версия 1.2a beta internal

- Быстрое умножение больших чисел по методу Карацубы, увеличивающее
  производительность при размере обоих операндов от 6,000 битов.

  ПРИМЕЧАНИЕ: Метод Карацубы относительно сложен в реализации
              и тестировании. Он введен в версию 1.2а класса
              как часть программы бета-тестирования. Если Вам
              нужны надежные вычислению, то его лучше отключить,
              для чего надо удалить из файла Cbignumf.inl макро
              _CBIGNUM_KARATSUBA_MUL.

- В связи с реализаций метода Карацубы, рекомендованный верхний предел
  для применения методов addmultab() and submultab() составляет теперь
  6,000 бит.

- Ограниченная экспериментальная поддержка многопоточных приложений
  с макро _CBIGNUM_MT.

- Новые операции cBigDivMod() и cBigSqrtRm().

- Новые машинно-зависимые методы set() и setr().

- ИСПРАВЛЕНО: Переполнение стека при сдвиге с отрицательным показателем
              LONG_MIN.

- ИСПРАВЛЕНО: Операции возведения в степень и степень по модулю
              переписывают cBigNumber::lastdivmod(), если показатель
              степень меньше 0.

- ИСПРАВЛЕНО: Опечатка во введении на английском к внутренним функциям
              cBigNumberMAddM(), cBigNumberMSubM(), _cBigNumberMSubD()
              (ошибка не затрагивает код).

- Для ввода-вывода по умолчанию используется стандартная библиотека
  iostream, если задействованы трансляторы Microsoft Visual C++ .NET,
  GNU g++ 3.x, 4.x и выше.

- Обеспечена компиляция в GNU g++ 4.1, кроме ассемблерных инструкций.

- Тест возведения в степень по модулю Arif2.bat.

- 32-битный ассемблер для Visual C++ и Borland C++ Builder
  (дополнительный пакет).


22.09.2007 - Версия 1.2a beta public

- Аппаратное умножение с применением ассемблерной команды MUL
  (в дополнительном пакете), выполняется в 10 раз быстрее.

  ПРИМЕЧАНИЕ: Ассемблерный дополнительный пакет не включен
              в свободно распространяемую версию класса.

- Две реализации метода Карацубы, оптимизированные соответственно
  для свободно распространяемого С кода и дополнительного
  ассемблерного пакета.

  ПРИМЕЧАНИЕ: Метод Карацубы относительно сложен в реализации
              и тестировании. Он введен в версию 1.2а класса
              как часть программы бета-тестирования. Если Вам
              нужны надежные вычислению, то его лучше отключить,
              для чего надо удалить из файла Cbignumf.inl макро
              _CBIGNUM_KARATSUBA_MUL.

- Быстрое копирование в отладочном режиме, если применяется
  дополнительный пакет.

- Дополнительное алгоритмические ускорение ввода чисел.

- Сравнение производительности с библиотекой NTL.

- ИСПРАВЛЕНО: Умножение отрицательного и положительного числа может
              дать некорректный результат в версии 1.2a beta internal.

- ИСПРАВЛЕНО: Макро _CBIGNUM_BLOCK_MUL может привести к переполнению
              буфера в версии 1.2a beta internal.

- ИСПРАВЛЕНО: Оператор вывода << может игнорировать флаги
              ios::uppercase и ios::showbase (Nicolas).

- ИСПРАВЛЕНО: Игнорируется модификатор width() потока вывода.

- ИСПРАВЛЕНО: Внутренняя функция cBigNumberCopyShr() не работает
              для ненормализованного 0.

- ИСПРАВЛЕНО: Увеличен размер буфера для внутренних функций
              cBigNumberPow(), cBigNumberPowMod().

- ИСПРАВЛЕНО: Размер буфера в спецификации к внутренним функциям
              cBigNumberMAddMulShl(), cBigNumberMSubMulShl(),
              cBigNumberMAddMulShlKar(), cBigNumberMSubMulShlKar()
              (ошибка не затрагивает код).

- ИСПРАВЛЕНО: Опция -size программы Arifexp и метод dump()
              работают неправильно под Visual C++ .NET.

- ИСПРАВЛЕНО: Программа Arifexp не проверяет остаток во время
              обратного теста умножения.

- Дополнения в Arifexp:
  - Выводится среднее время под опцией -rep.
  - Более эффективный тест умножения под опцией -check.
  - Опция -time.

- Проверена совместимость с Microsoft Visual C++ Express 2008.


12.06.2009 - Версия 1.2b beta public

- Реентерабельный метод toa() вместо подлежащего исключению toatmp().

- Операции cBigBits() и cBigExBits().

- Новые файлы Cbignumf.h and Cbnl.h обеспечивают зависимую от
  компилятора информацию для более аккуратной оценки времени
  выполнения в программе Arifexp.

- Программа Arifexp проверяет корректность преобразования числа в строку
  если задана опция -check.

- Оператор сравнения ? в программе Arifexp и тест сравнения в Arifrand.bat.

- ИСПРАВЛЕНО: Программа Arifexp не выдает код ошибки на неверных выражениях.

- ИСПРАВЛЕНО: Оценка времени умножения в программе Arifexp.

- ИСПРАВЛЕНО: Оценка времени деления в программе Arifexp и документации.

- ИСПРАВЛЕНО: Оценки времени выполнения в программе Arifexp под Linux.


28.07.2009 - Версия 1.2b public

- Оптимизация блочного умножения в дополнительном ассемблерном пакете,
  когда неприменим метод Карцубы (до 5% увеличения производительности,
  если один операнд меньше 50 long слов, а второй операнд в 10
  и более раз больше).

- Новые методы addmulsmp() и submulsmp() используют аппаратное умножение,
  если оно задействовано, вместо таблицы сдвигов. Методы addmultab()
  и submultab() всегда используют таблицу сдвигов.

- Новый метод smp() строит таблицу сдвигов, если аппаратное умножение
  не задействовано.

- Новая версия шаблона Exarray.h для работы в 64-разрядном режиме.

- Генератор Random3 приспособлен для работы в 64-разрядном режиме.

- Обеспечена совместимость с GNU g++ 4.1.2 в 64-разрядном режиме.

- Обеспечена совместимость с GNU g++ 4.2.3.

- Gettimer.c поддерживает DPMI в Borland C++ 4.5.

- Gettimer.c использует операции long вместо double, где это возможно.

- ИСПРАВЛЕНО: Программа Arifexp неверно выполняет ++ и -- под ключом -v.

- ИСПРАВЛЕНО: Программы не возвращают код 255.

- Командный файл Millrand.bat для тестирования на простоту.

- 32-разрядные исполняемые файлы для Pocket PC в дополнительном пакете.

- 64-разрядные исполняемые файлы для Linux и тестовые файлы .sh.

- Производительность в 64-разрядном режиме под Linux в разделе 4.2.

- Производительность под ARM Pocket PC в разделе 4.2.

- ИСПРАВЛЕНО: Производительность в ассемблерном режиме для процессоров
              Pentium III/933 и Pentium 4C/2400 по тестам Arif1-3
              в разделе 4.2.

- Проведено сокращенное тестирование в 64-разрядном режиме.

- Бета-тестирование завершено.


27.08.2009 - Обновление документации к версии 1.2b public

- Тесты производительности для ARM, Intel Atom и AMD Phenom.


19.11.2009 - Дополнения к версии 1.2b public

- Тест голосования при умножении с помощью addmultab()/submultab() в
  программе Arifexp.

- Быстрая факторизация 64-разрядных чисел с применением 64-разрядного
  машинного деления в Prime.cpp, актуальная для 64-разрядного g++.

- Программа Miller64 для быстрой факторизации 64-разрядных чисел
  под 64-разрядным Linux.


15.12.2009 - Версия 1.2c beta internal

- Класс получил реентерабельный код с поддержкой многопоточности.

- ИЗМЕНЕНИЕ: Макро _CBIGNUM_MT включено по умолчанию.

- ИЗМЕНЕНИЕ: Исключены нереентерабельные статические методы
             lastdivmod(), lastrootrm(), кроме случая отключения
             макро _CBIGNUM_MT. Замените их на реентерабельные
             операции cBigDivMod(), cBigSqrtRm() или методы
             setdivmod(), setsqrtrm().

- ИЗМЕНЕНИЕ: Исключен нереентерабельный метод toatmp(), если
             только не отключено макро _CBIGNUM_MT или установлено
             макро _CBIGNUM_TOATMP. Замените его на метод toa().

- Преобразование строка-число и вычисление квадратного корня
  оптимизированы для макро _CBIGNUM_MT.

- Умножение, деление, модуль, степень и возведение в степень по модулю
  оптимизированы для чисел, кратных большой степени двойки (~100 и выше)
  под макро _CBIGNUM_MT.

- Возведение в степень по модулю оптимизировано для модуля, кратного
  большой степени двойки (~100 и выше).

- Специальный код для ~10-кратного ускорения деления и модуля чисел
  с одним значащим словом.

- В несколько раз ускорено выполнение методов bits() и exbits().


10.01.2010 - Обновление версии 1.2c beta internal

- Заголовочный файл Cthr.h для поддержки многопоточности в приложениях.

- ИСПРАВЛЕНО: Гонки в классе cBigTemp при многопоточном режиме (но
              класс стал работать медленнее - это будет поправлено в
              версии beta public).

- ИСПРАВЛЕНО: Неправильная реализация метода set(a,n) для типа long.


28.07.2010 - Версия 1.2c beta pubic

- Реализована поддержка локальной памяти потока в классе cBigTemp,
  что сделало версию 1.2c в многопоточном режиме такой же быстрой,
  как предыдущую версию 1.2b в однопоточном режиме. См. описание
  макро EXTHREAD_LOCAL в разделе 3.

- Заголовочный файл Exthread.h автоматически определяет макро
  EXTHREAD_LOCAL для трансляторов Borland/Microsoft и GNU g++.

- Добавлена опция -par n в программу Arifexp для организации вывода
  данных в параллельном потоке под Windows.

- Программа Arifexp теперь не выводит результат проверки, если она
  совпадает с исходными данными.

- Работа командного файла Arifrand.bat ускорена в 2-3 раза за счет вывода
  данных в параллельном потоке и отказа от вывода проверочных данных.

- ИСПРАВЛЕНО: Гонки в методах ввода-вывода в многопоточном режиме.


27.09.2010 - Обновление версии 1.2b public

- ИСПРАВЛЕНО: Некорректная реализация cBigAbs() и setabs().

- ИСПРАВЛЕНО: Некорректная реализация cBigExBits() и setexbits(),
              неправильный пример в описании cBigExBits().


28.09.2010 - Обновление версии 1.2c beta pubic

- Тест производительности для Intel Core i7.

- Программа Arifexp и тестовый файл Arifrand.bat выполняют операции
  ~, @(abs), U(unsign), M(bits), U(exbits).

- Усовершенствован метод оценки времени в программе Arifexp.

- ИСПРАВЛЕНО: Некорректная реализация cBigAbs() и setabs().

- ИСПРАВЛЕНО: Некорректная реализация cBigExBits() и setexbits(),
              неправильный пример в описании cBigExBits().

- ИСПРАВЛЕНО: Ошибка распределения памяти в методах преобразования
              числа в строку и строки в число.

- ИСПРАВЛЕНО: Неверный результат cBigCompl() и setcompl()
              для числа из 0 слов.

- ИСПРАВЛЕНО: Неверный результат +, -, ^, &, | для числа из 0 слов
              и машинного числа.

- ИСПРАВЛЕНО: Метод loword() может выдать неверный результат для
              числа из 0 слов.

- ИСПРАВЛЕНО: Порча памяти методами tab() и smp() для числа из 0 слов.

- ИСПРАВЛЕНО: Ошибка assert в отладочном режиме при возведении
              в степень по модулю базы из 0 слов.

- ИСПРАВЛЕНО: Оценка времени сложения и вычитания в программе Arifexp.

- Обновлена оценка времени деления.


01.10.2010 - Версия 2.0 beta internal

- ИЗМЕНЕНИЕ: Вместо типа long применяется тип CBNL, определенный в
             Cbnl.h для обработки 64-разрядных чисел под Visual C++
             в 64-разрядом режиме.

- ИЗМЕНЕНИЕ: Методы code(), loword(), hiword(), bits(), exbits()
             теперь выдают значение типа CBNL, которое в зависимости
             от транслятора может быть long, __int64, __int128 и т.д.

- ИЗМЕНЕНИЕ: Число со значением 0 может состоять из 0 слов.

- Все конструкторы, операции присваивания и метод set() не выделяют
  память для числа 0, если память не была распределена ранее
  (память выделяется при присваивании ненулевого значения или при
  выполнении модифицирующей операции, даже если ее результат 0).

- Методы gc() и pack() освобождают всю память, выделенную под число 0.

- 64-битный ассемблер для Visual C++ (в дополнительном пакете),
  ускорение в 3-40 раз для процессоров AMD.

- Файлы для определения компилятора Cbnl.inl and Cbnl64.inl
  (в дополнительном пакете).

- Программы Arifexp64, Matrix64, Miller64 для 64-разрядной
  Windows.

- Файлы .bat вызывают 64-разрядные программы под 64-разрядной Windows.

- Новый метод преобразования toCBNL().

- Документирован метод clear(), обеспечена его корректная работа.

- Тесты и оценки производительности для 64-разрядного режима в
  разделе 4.2, в том числе для Intel Core i7 и AMD Phenom.


20.11.2010 - Обновление версии 2.0 beta internal

- Соглашение fastcall для вызова критических функций в 32-разрядном
  режиме Visual C++ как опция компиляции в Cbnl.h.
  По умолчанию отключено, т.к. неэффективно.

- Альтернативный 32-разрядный ассемблерный код для Visual C++ с
  соглашением о связи fastcall как опция компиляции в Cbnl.h.
  По умолчанию отключен, т.к. неэффективен.

- Удалены лишние операции из 64-разрядного ассемблерного кода.

- Документированы макро _CBIGNUM_DEF_ALLOC и _CBIGNUM_NCHECKPTR.

- Поправлены разделы 1.1, 1.2 и 4.3 документации.


22.11.2010 - Дополнения к версии 2.0 beta internal

- Аппаратное умножение с применением ассемблерной команды MUL для
  GNU g++ (в дополнительном пакете), выполняется в 8 раз быстрее.

- Исполняемые файлы для Linux с ускоренным 32/64-разрядным
  аппаратным умножением.


30.03.2011 - Версия 1.2c pubic

- Документирован метод clear(), обеспечена его корректная работа.

- Поправлены разделы 1.1, 1.2 и 4.3 документации.

- Бета-тестирование завершено.


30.03.2011 - Версия 2.0 beta pubic

- Внутреннее тестирование завершено.


05.03.2013 - Версия 2.0 pubic

- Тест производительности для AMD FX.

- Бета-тестирование завершено.


12.03.2013 - Обновление документации к версии 2.0 pubic

- Убрано ограничение реентерабельности из списка ошибок.

- Сведения о разреженных массивах в разделе 4.3.


12.03.2013
